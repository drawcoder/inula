'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var TYPE_COMMON_ELEMENT = 1;
var TYPE_PORTAL = 2;
var TYPE_FRAGMENT = 3;
var TYPE_STRICT_MODE = 4;
var TYPE_PROVIDER = 5;
var TYPE_CONTEXT = 6;
var TYPE_FORWARD_REF = 7;
var TYPE_SUSPENSE = 8;
var TYPE_PROFILER = 9;
var TYPE_MEMO = 10;
var TYPE_LAZY = 11;
var TYPE_TEMPLATE = 12;

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
/**
 * Component的api setState和forceUpdate在实例生成阶段实现
 */
var Component = /*#__PURE__*/function () {
  function Component(props, context) {
    _classCallCheck(this, Component);
    this.props = void 0;
    this.context = void 0;
    this.state = void 0;
    this.refs = void 0;
    this.forceUpdate = void 0;
    this.isReactComponent = void 0;
    this.props = props;
    this.context = context;
  }
  _createClass(Component, [{
    key: "setState",
    value: function setState(state, callback) {
    }
  }]);
  return Component;
}(); // 兼容三方件 react-lifecycles-compat，它会读取 isReactComponent 属性值，不添加会导致 eview-ui 官网白屏
Component.prototype.isReactComponent = true;

/**
 * 支持PureComponent
 */
var PureComponent = /*#__PURE__*/function (_Component) {
  _inherits(PureComponent, _Component);
  var _super = _createSuper(PureComponent);
  function PureComponent(props, context) {
    _classCallCheck(this, PureComponent);
    return _super.call(this, props, context);
  }
  return _createClass(PureComponent);
}(Component);

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function createRef() {
  return {
    current: null
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 当条件不成立报错
// 接收模板
function throwIfTrue(condition, errTemplate) {
  for (var _len = arguments.length, errExpressions = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    errExpressions[_key - 2] = arguments[_key];
  }
  if (condition) {
    // 将%s 替换成对应的变量
    var msg = errTemplate.split('%s').reduce(function (prevSentence, part, idx) {
      // %s对应的变量
      var expression = idx < errExpressions.length ? errExpressions[idx] : '';
      return prevSentence + part + expression;
    }, '');
    throw Error(msg);
  }
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 当前处理的classVNode，用于设置inst.refs
var processingClassVNode = null;
function getProcessingClassVNode() {
  return processingClassVNode;
}
function setProcessingClassVNode(vNode) {
  processingClassVNode = vNode;
}

// capture阶段正在处理的VNode
var processingVNode = null;
function getProcessingVNode() {
  return processingVNode;
}
function setProcessingVNode(vNode) {
  processingVNode = vNode;
}

// 计算出来的刷新节点，不一定是根节点
var startVNode = null;
function getStartVNode() {
  return startVNode;
}
function setStartVNode(vNode) {
  startVNode = vNode;
}
var BuildInComplete = 0;
var BuildFatalErrored = 1;
var BuildErrored = 2;
var BuildCompleted = 3;
// 根节点退出build tree时的状态，如: completed, incomplete, errored, fatalErrored.
var buildVNodeResult = BuildInComplete;
function setBuildResult(result) {
  buildVNodeResult = result;
}
function getBuildResult() {
  return buildVNodeResult;
}

// Using register component function, you can globally register function to horizon.
// This function can be then called using JSX without importing it in other component files.
// USE LOWERCASE NAMES ONLY. Otherwise jsx parser will mistake it with imported component.
var componentRegister;
function getComponentRegister() {
  if (!componentRegister) componentRegister = new Map();
  return componentRegister;
}
function kebab(value) {
  return value.replaceAll(/([a-z])([A-Z])/g, '$1-$2').replaceAll(/\s+/g, '-').toLowerCase();
}
function registerComponent(name, component) {
  if (isComponentRegistered(name)) throw Error('Component with name "' + name + '" is already registered.');
  getComponentRegister().set(kebab(name), component);
}
function isComponentRegistered(name) {
  return getComponentRegister().has(kebab(name));
}

/**
 * vtype 节点的类型，这里固定是element
 * type 保存dom节点的名称或者组件的函数地址
 * key key属性
 * ref ref属性
 * props 其他常规属性
 */
function JSXElement(type, key, ref, vNode, props, source) {
  var ele = {
    // 元素标识符
    vtype: TYPE_COMMON_ELEMENT,
    src: null,
    // 属于元素的内置属性
    type: type,
    key: key,
    ref: ref,
    props: props,
    // 所属的class组件
    belongClassVNode: null
  };

  // 在 cloneDeep JSXElement 的时候会出现死循环，需要设置belongClassVNode的enumerable为false
  Object.defineProperty(ele, 'belongClassVNode', {
    configurable: false,
    enumerable: false,
    value: vNode
  });
  if (typeof type === 'function' && ref) {
    ref.current = new Proxy(ele, {
      get: function (target, prop) {
        var _target$props, _target$props$expose;
        return target === null || target === void 0 ? void 0 : (_target$props = target.props) === null || _target$props === void 0 ? void 0 : (_target$props$expose = _target$props.expose) === null || _target$props$expose === void 0 ? void 0 : _target$props$expose[prop];
      }
    });
  }
  return ele;
}
function isValidKey(key) {
  var keyArray = ['key', 'ref', '__source', '__self'];
  return !keyArray.includes(key);
}
function mergeDefault(sourceObj, defaultObj) {
  Object.keys(defaultObj).forEach(function (key) {
    if (sourceObj[key] === undefined) {
      sourceObj[key] = defaultObj[key];
    }
  });
}
var templates;
function buildElement(isClone, type, setting, children) {
  var _setting;
  // setting中的值优先级最高，clone情况下从 type 中取值，创建情况下直接赋值为 null

  function toArray(item) {
    if (!item) return [];
    if (Array.isArray(item)) return item;
    return [item];
  }
  if (typeof type === 'string' && isComponentRegistered(type)) {
    type = getComponentRegister().get(type);
  }
  if (type === 'slottedElement') {
    templates = toArray(children[0].props.children).filter(function (child) {
      return (child === null || child === void 0 ? void 0 : child.vtype) === TYPE_TEMPLATE;
    });
    children[0].props.templates = templates;
    return children[0];
  }
  if (type === 'slot') {
    var template;
    if (setting.name) {
      var _setting$templates;
      template = (_setting$templates = setting.templates) === null || _setting$templates === void 0 ? void 0 : _setting$templates.find(function (temp) {
        return temp.props.name === setting.name;
      });
    } else {
      template = setting.templates;
    }
    if (template) {
      var _template, _template$props, _template2, _template2$props;
      return typeof ((_template = template) === null || _template === void 0 ? void 0 : (_template$props = _template.props) === null || _template$props === void 0 ? void 0 : _template$props.children) === 'function' ? template.props.children(setting) : (_template2 = template) === null || _template2 === void 0 ? void 0 : (_template2$props = _template2.props) === null || _template2$props === void 0 ? void 0 : _template2$props.children;
    }
    return children;
  }
  if (type === 'template') {
    if (!setting) setting = {};
    if (!setting.name) setting.name = 'default';
    return {
      vtype: TYPE_TEMPLATE,
      src: null,
      type: type,
      props: _extends({}, setting, {
        children: setting.is ? setting.is : function () {
          return children;
        }
      }),
      belongClassVNode: null
    };
    // return children;
  }

  var key = setting && setting.key !== undefined ? String(setting.key) : isClone ? type.key : null;
  var ref = setting && setting.ref !== undefined ? setting.ref : isClone ? type.ref : null;
  var props = isClone ? _extends({}, type.props) : {};
  var vNode = isClone ? type.belongClassVNode : getProcessingClassVNode();
  if (setting !== null && setting !== undefined) {
    var keys = Object.keys(setting);
    var keyLength = keys.length;
    for (var i = 0; i < keyLength; i++) {
      var k = keys[i];
      if (isValidKey(k)) {
        props[k] = setting[k];
      }
    }
    if (setting.ref !== undefined && isClone) {
      vNode = getProcessingClassVNode();
    }
  }
  if (children.length) {
    props.children = children.length === 1 ? children[0] : children;
  }
  var element = isClone ? type.type : type;
  // 合并默认属性
  if (element && element.defaultProps) {
    mergeDefault(props, element.defaultProps);
  }
  if ((_setting = setting) !== null && _setting !== void 0 && _setting.__source) {
    ({
      fileName: setting.__source.fileName,
      lineNumber: setting.__source.lineNumber
    });
  }
  var jsxElement = JSXElement(element, key, ref, vNode, props);
  return jsxElement;
}

// 创建Element结构体，供JSX编译时调用
function createElement(type, setting) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  var element = buildElement(false, type, setting, children);
  return element;
}
function cloneElement(element, setting) {
  for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    children[_key2 - 2] = arguments[_key2];
  }
  return buildElement(true, element, setting, children);
}

// 检测结构体是否为合法的Element
function isValidElement(element) {
  return !!(element && element.vtype === TYPE_COMMON_ELEMENT);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 生成key
function getItemKey(item, index) {
  if (typeof item === 'object' && item !== null && item.key != null) {
    return '.$' + item.key;
  }
  // 使用36进制减少生成字符串的长度以节省空间
  return '.' + index.toString(36);
}
function mapChildrenToArray(children, arr, prefix, callback) {
  var type = typeof children;
  switch (type) {
    // 继承原有规格，undefined和boolean类型按照null处理
    case 'undefined':
    case 'boolean':
      callMapFun(null, arr, prefix, callback);
      return;
    case 'number':
    case 'string':
      callMapFun(children, arr, prefix, callback);
      return;
    case 'object':
      if (children === null) {
        callMapFun(null, arr, prefix, callback);
        return;
      }
      var vtype = children.vtype;
      if (vtype === TYPE_COMMON_ELEMENT || vtype === TYPE_PORTAL) {
        callMapFun(children, arr, prefix, callback);
        return;
      }
      if (Array.isArray(children)) {
        processArrayChildren(children, arr, prefix, callback);
        return;
      }
      throw new Error('Object is invalid as a Horizon child. ');
    // No Default
  }
}

function processArrayChildren(children, arr, prefix, callback) {
  for (var i = 0; i < children.length; i++) {
    var childItem = children[i];
    var nextPrefix = prefix + getItemKey(childItem, i);
    mapChildrenToArray(childItem, arr, nextPrefix, callback);
  }
}
function callMapFun(children, arr, prefix, callback) {
  var mappedChild = callback(children);
  if (Array.isArray(mappedChild)) {
    // 维持原有规格，如果callback返回结果是数组，处理函数修改为返回数组item
    processArrayChildren(mappedChild, arr, prefix + '/', function (subChild) {
      return subChild;
    });
  } else if (mappedChild !== null && mappedChild !== undefined) {
    // 给一个key值，确保返回的对象一定带有key
    if (isValidElement(mappedChild)) {
      var childKey = prefix === '' ? getItemKey(children, 0) : '';
      var mappedKey = getItemKey(mappedChild, 0);
      var newKey = prefix + childKey + (mappedChild.key && mappedKey !== getItemKey(children, 0) ? '.$' + mappedChild.key : '');
      // 返回一个修改key的children
      mappedChild = JSXElement(mappedChild.type, newKey, mappedChild.ref, mappedChild.belongClassVNode, mappedChild.props, mappedChild.src);
    }
    arr.push(mappedChild);
  }
}

// 在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg
function mapChildren(children, func, context) {
  if (children === null || children === undefined) {
    return children;
  }
  var count = 0;
  var result = [];
  mapChildrenToArray(children, result, '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
var Children = {
  forEach: function (children, func, context) {
    // 不返回数组即可
    mapChildren(children, func, context);
  },
  map: mapChildren,
  // 并非所有元素都会计数,只计数调用callMapFun函数次数
  count: function (children) {
    var n = 0;
    mapChildren(children, function () {
      n++;
    });
    return n;
  },
  only: function (children) {
    throwIfTrue(!isValidElement(children), 'Horizon.Children.only function received invalid element.');
    return children;
  },
  toArray: function (children) {
    var result = [];
    mapChildrenToArray(children, result, '', function (child) {
      return child;
    });
    return result;
  }
};

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createContext(val) {
  var context = {
    vtype: TYPE_CONTEXT,
    value: val,
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    vtype: TYPE_PROVIDER,
    _context: context
  };
  context.Consumer = context;
  return context;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var LayStatus = /*#__PURE__*/function (LayStatus) {
  LayStatus["UnProcessed"] = "UnProcessed";
  LayStatus["Pending"] = "Pending";
  LayStatus["Fulfilled"] = "Fulfilled";
  LayStatus["Rejected"] = "Rejected";
  return LayStatus;
}(LayStatus || {});
// lazyContent随着阶段改变，_value改变:
// 1. 未初始化 -> promiseCtor: () => promise
// 2. pending -> promise
// 3. fulfilled -> module
// 4. rejected -> error
function lazyLoader(lazyContent) {
  if (lazyContent._status === LayStatus.UnProcessed) {
    // 执行动态导入组件import
    var promise = lazyContent._value();
    lazyContent._status = LayStatus.Pending;
    lazyContent._value = promise;
    promise.then(function (module) {
      if (lazyContent._status === LayStatus.Pending) {
        var defaultExport = module.default;
        lazyContent._status = LayStatus.Fulfilled;
        lazyContent._value = defaultExport;
      }
    }, function (error) {
      if (lazyContent._status === LayStatus.Pending) {
        lazyContent._status = LayStatus.Rejected;
        lazyContent._value = error;
      }
    });
  }
  if (lazyContent._status === LayStatus.Fulfilled) {
    return lazyContent._value;
  } else {
    throw lazyContent._value;
  }
}
function lazy(promiseCtor) {
  return {
    vtype: TYPE_LAZY,
    _content: {
      _status: LayStatus.UnProcessed,
      _value: promiseCtor
    },
    _load: lazyLoader
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function forwardRef(render) {
  return {
    vtype: TYPE_FORWARD_REF,
    render: render
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function memo(type, compare) {
  return {
    vtype: TYPE_MEMO,
    type: type,
    compare: compare === undefined ? null : compare
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 定义vNode的类型
 */

var TreeRoot = 'TreeRoot'; // tree的根节点，用于存放一些tree级的变量
var FunctionComponent = 'FunctionComponent';
var ClassComponent = 'ClassComponent';
var DomPortal = 'DomPortal';
var DomComponent = 'DomComponent';
var DomText = 'DomText';
var Fragment = 'Fragment';
var ContextConsumer = 'ContextConsumer';
var ContextProvider = 'ContextProvider';
var ForwardRef = 'ForwardRef';
var SuspenseComponent = 'SuspenseComponent';
var MemoComponent = 'MemoComponent';
var LazyComponent = 'LazyComponent';

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var INTERNAL_VNODE = '_horizon_VNode';
var INTERNAL_PROPS = '_horizon_Props';
var INTERNAL_NONDELEGATEEVENTS = '_horizon_NonDelegatedEvents';

// 通过 VNode 实例获取 DOM 节点
function getDom(vNode) {
  var tag = vNode.tag;
  if (tag === DomComponent || tag === DomText) {
    return vNode.realNode;
  }
  return null;
}

// 将 VNode 属性相关信息挂到 DOM 对象的特定属性上
function saveVNode(vNode, dom) {
  dom[INTERNAL_VNODE] = vNode;
}

// 用 DOM 对象，来寻找其对应或者说是最近父级的 vNode
function getNearestVNode(dom) {
  var domNode = dom;
  // 寻找当前节点及其所有祖先节点是否有标记VNODE
  while (domNode) {
    var vNode = domNode[INTERNAL_VNODE];
    if (vNode) {
      return vNode;
    }
    domNode = domNode.parentNode;
  }
  return null;
}

// 获取 vNode 上的属性相关信息
function getVNodeProps(dom) {
  return dom[INTERNAL_PROPS] || null;
}

// 将 DOM 属性相关信息挂到 DOM 对象的特定属性上
function updateVNodeProps(dom, props) {
  dom[INTERNAL_PROPS] = props;
}
function getNonDelegatedListenerMap(dom) {
  var eventsMap = dom[INTERNAL_NONDELEGATEEVENTS];
  if (!eventsMap) {
    eventsMap = new Map();
    dom[INTERNAL_NONDELEGATEEVENTS] = eventsMap;
  }
  return eventsMap;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * vNode结构的变化标志
 */

var InitFlag = /**     */0;
// vNode节点的flags
var DirectAddition = /**  */1 << 0; // 在本次更新前入股父dom没有子节点，说明本次可以直接添加至父节点，不需要通过 getSiblingDom 找到 before 节点
var Addition = /**     */1 << 1;
var Update = /**     */1 << 2;
var Deletion = /**     */1 << 3;
var ResetText = /**     */1 << 4;
var Callback = /**     */1 << 5;
var DidCapture = /**     */1 << 6;
var Ref = /**     */1 << 7;
var Snapshot = /**     */1 << 8;
var Interrupted = /**     */1 << 9; // 被中断了，抛出错误的vNode以及它的父vNode
var ShouldCapture = /**     */1 << 11;
var ForceUpdate = /**     */1 << 12; // For suspense
var Clear = /**     */1 << 13;
var LifecycleEffectArr = Update | Callback | Ref | Snapshot;
var FlagUtils = /*#__PURE__*/function () {
  function FlagUtils() {
    _classCallCheck(this, FlagUtils);
  }
  _createClass(FlagUtils, null, [{
    key: "removeFlag",
    value: function removeFlag(node, flag) {
      node.flags &= ~flag;
    }
  }, {
    key: "removeLifecycleEffectFlags",
    value: function removeLifecycleEffectFlags(node) {
      node.flags &= ~LifecycleEffectArr;
    }
  }, {
    key: "hasAnyFlag",
    value: function hasAnyFlag(node) {
      // 有标志位
      return node.flags !== InitFlag;
    }
  }, {
    key: "setNoFlags",
    value: function setNoFlags(node) {
      node.flags = InitFlag;
    }
  }, {
    key: "markAddition",
    value: function markAddition(node) {
      node.flags |= Addition;
    }
  }, {
    key: "setAddition",
    value: function setAddition(node) {
      node.flags = Addition;
    }
  }, {
    key: "markDirectAddition",
    value: function markDirectAddition(node) {
      node.flags |= DirectAddition;
    }
  }, {
    key: "markUpdate",
    value: function markUpdate(node) {
      node.flags |= Update;
    }
  }, {
    key: "setDeletion",
    value: function setDeletion(node) {
      node.flags = Deletion;
    }
  }, {
    key: "markContentReset",
    value: function markContentReset(node) {
      node.flags |= ResetText;
    }
  }, {
    key: "markCallback",
    value: function markCallback(node) {
      node.flags |= Callback;
    }
  }, {
    key: "markDidCapture",
    value: function markDidCapture(node) {
      node.flags |= DidCapture;
    }
  }, {
    key: "markShouldCapture",
    value: function markShouldCapture(node) {
      node.flags |= ShouldCapture;
    }
  }, {
    key: "markRef",
    value: function markRef(node) {
      node.flags |= Ref;
    }
  }, {
    key: "markSnapshot",
    value: function markSnapshot(node) {
      node.flags |= Snapshot;
    }
  }, {
    key: "markInterrupted",
    value: function markInterrupted(node) {
      node.flags |= Interrupted;
    }
  }, {
    key: "markForceUpdate",
    value: function markForceUpdate(node) {
      node.flags |= ForceUpdate;
    }
  }, {
    key: "markClear",
    value: function markClear(node) {
      node.flags |= Clear;
    }
  }]);
  return FlagUtils;
}();

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function travelChildren(beginVNode, handleVNode, isFinish) {
  var node = beginVNode;
  while (node !== null) {
    if (isFinish && isFinish(node)) {
      return;
    }
    handleVNode(node);
    node = node.next;
  }
}

// 从beginVNode开始深度遍历vNode树，对每个vNode调用handleVNode方法
function travelVNodeTree(beginVNode, handleVNode, childFilter,
// 返回true不处理child
finishVNode,
// 结束遍历节点，有时候和beginVNode不相同
handleWhenToParent) {
  var node = beginVNode;
  while (true) {
    var ret = handleVNode(node);
    // 如果处理一个vNode时有返回值，则中断遍历
    if (ret) {
      return ret;
    }

    // 找子节点
    var childVNode = node.child;
    if (childVNode !== null && (childFilter === null || !childFilter(node))) {
      childVNode.parent = node;
      node = childVNode;
      continue;
    }

    // 回到开始节点
    if (node === finishVNode) {
      return null;
    }

    // 找兄弟，没有就往上再找兄弟
    while (node.next === null) {
      if (node.parent === null || node.parent === finishVNode) {
        return null;
      }
      node = node.parent;
      if (typeof handleWhenToParent === 'function') {
        handleWhenToParent(node);
      }
    }
    // 找到兄弟
    var siblingVNode = node.next;
    siblingVNode.parent = node.parent;
    node = siblingVNode;
  }
}

// 置空vNode
function clearVNode(vNode) {
  vNode.isCleared = true;
  vNode.child = null;
  vNode.next = null;
  vNode.depContexts = null;
  vNode.dirtyNodes = null;
  vNode.state = null;
  vNode.hooks = null;
  vNode.props = null;
  vNode.parent = null;
  vNode.suspenseState = null;
  vNode.changeList = null;
  vNode.effectList = null;
  vNode.updates = null;
  vNode.realNode = null;
  vNode.oldProps = null;
  vNode.oldHooks = null;
  vNode.oldState = null;
  vNode.oldRef = null;
  vNode.oldChild = null;
  vNode.toUpdateNodes = null;
  vNode.belongClassVNode = null;
  if (window.__HORIZON_DEV_HOOK__) {
    var hook = window.__HORIZON_DEV_HOOK__;
    hook.deleteVNode(vNode);
  }
}

// 是dom类型的vNode
function isDomVNode(node) {
  return node.tag === DomComponent || node.tag === DomText;
}

// 是容器类型的vNode
function isDomContainer(vNode) {
  return vNode.tag === DomComponent || vNode.tag === TreeRoot || vNode.tag === DomPortal;
}
function findDomVNode(vNode) {
  return travelVNodeTree(vNode, function (node) {
    if (node.tag === DomComponent || node.tag === DomText) {
      return node;
    }
    return null;
  }, null, vNode, null);
}
function findDOMByClassInst(inst) {
  var vNode = inst._vNode;
  if (vNode === undefined) {
    throw new Error('Unable to find the vNode by class instance.');
  }
  var domVNode = findDomVNode(vNode);
  return domVNode !== null ? domVNode.realNode : null;
}

// 找到相邻的DOM
function getSiblingDom(vNode) {
  var node = vNode;
  findSibling: while (true) {
    // 没有兄弟节点，找父节点
    while (node.next === null) {
      // 没父节点，或父节点已经是根节点，则返回
      if (node.parent === null || isDomContainer(node.parent)) {
        return null;
      }
      node = node.parent;
    }
    var siblingVNode = node.next;
    siblingVNode.parent = node.parent;
    node = siblingVNode;

    // 如果不是dom节点，往下找
    while (!isDomVNode(node)) {
      // 如果节点也是Addition
      if ((node.flags & Addition) === Addition) {
        continue findSibling;
      }

      // 没有子节点，或是DomPortal
      if (!node.child || node.tag === DomPortal) {
        continue findSibling;
      } else {
        var childVNode = node.child;
        childVNode.parent = node;
        node = childVNode;
      }
    }
    if ((node.flags & Addition) === InitFlag) {
      // 找到
      return node.realNode;
    }
  }
}
function isPortalRoot(vNode, targetContainer) {
  if (vNode.tag === DomPortal) {
    var topVNode = vNode.parent;
    while (topVNode !== null) {
      var grandTag = topVNode.tag;
      if (grandTag === TreeRoot || grandTag === DomPortal) {
        var topContainer = topVNode.realNode;
        // 如果topContainer是targetContainer，不需要在这里处理
        if (topContainer === targetContainer) {
          return true;
        }
      }
      topVNode = topVNode.parent;
    }
    return false;
  }
  return false;
}

// 获取根vNode节点
function findRoot(targetVNode, targetDom) {
  // 确认vNode节点是否准确，portal场景下可能祖先节点不准确
  var vNode = targetVNode;
  while (vNode !== null) {
    if (vNode.tag === TreeRoot || vNode.tag === DomPortal) {
      var dom = vNode.realNode;
      if (dom === targetDom) {
        break;
      }
      if (isPortalRoot(vNode, targetDom)) {
        return null;
      }
      while (dom !== null) {
        var parentNode = getNearestVNode(dom);
        if (parentNode === null) {
          return null;
        }
        if (parentNode.tag === DomComponent || parentNode.tag === DomText) {
          return findRoot(parentNode, targetDom);
        }
        dom = dom.parentNode;
      }
    }
    vNode = vNode.parent;
  }
  if (vNode === null) {
    return null;
  }
  return targetVNode;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 浏览器相关实现
 */

var isMessageLoopRunning = false;
var browserCallback = null;
var port1 = null;
var port2 = null;
var isTestRuntime = false;
function isOverTime() {
  return false;
}

// 1、设置deadline；2、回调TaskExecutor传过来的browserCallback
var callRenderTasks = function () {
  if (browserCallback === null) {
    return;
  }
  try {
    // 执行callback
    var hasMoreTask = browserCallback();
    if (!hasMoreTask) {
      // 没有更多task
      isMessageLoopRunning = false;
      browserCallback = null;
    } else {
      // 还有task，继续调用
      asyncCall();
    }
  } catch (error) {
    asyncCall();
    throw error;
  }
};
if (typeof MessageChannel === 'function') {
  var mc = new MessageChannel();
  port1 = mc.port1;
  port1.onmessage = callRenderTasks;
  port2 = mc.port2;
} else {
  // 测试环境没有 MessageChannel
  isTestRuntime = true;
}
function asyncCall() {
  if (isTestRuntime) {
    setTimeout(callRenderTasks, 0);
  } else {
    port2.postMessage(null);
  }
}
function requestBrowserCallback(callback) {
  browserCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    asyncCall();
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 任务列表的实现
 */

// 任务队列
var taskQueue = [];
function compare(a, b) {
  // 优先先用index排序，其次用id
  var diff = a.order - b.order;
  return diff !== 0 ? diff : a.id - b.id;
}

// 二分法查找第一个大于等于 value 的下标，都比 value 小则返回 -1，时间复杂度O(logn)
function getBiggerIdx(node) {
  var left = 0;
  var right = taskQueue.length - 1;
  while (left <= right) {
    var middle = left + (right - left >> 1);
    if (compare(taskQueue[middle], node) > 0) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }
  return left < taskQueue.length ? left : -1;
}
function add$1(node) {
  // 查找第一个大于等于 value 的下标，都比 value 小则返回 -1
  var idx = getBiggerIdx(node);
  if (idx === -1) {
    taskQueue.push(node);
  } else {
    taskQueue.splice(idx, 0, node);
  }
}
function first() {
  var val = taskQueue[0];
  return val !== undefined ? val : null;
}
function shift() {
  var val = taskQueue.shift();
  return val !== undefined ? val : null;
}
function remove(node) {
  taskQueue.splice(taskQueue.indexOf(node), 1);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var ImmediatePriority = 1;
var NormalPriority = 10;

// 用于控制插入任务的顺序
var idCounter = 1;

// 正在执行task
var isProcessing = false;

// 调度中，等待浏览器回调
var isWaiting = false;
function callTasks() {
  isWaiting = false;
  isProcessing = true;
  var task = null;
  try {
    task = first();

    // 循环执行task
    while (task !== null) {
      if (isOverTime()) ;
      var callback = task.callback;
      if (callback !== null) {
        task.callback = null;
        callback();
        if (task === first()) {
          shift();
        } else {
          // 执行任务中可能插入了新任务
          remove(task);
        }
      } else {
        shift();
      }
      task = first();
    }

    // 返回是否还有任务，如果有，说明是被中断了
    return task !== null;
  } finally {
    isProcessing = false;
  }
}
function runAsync(callback) {
  var priorityLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NormalPriority;
  var increment;
  switch (priorityLevel) {
    case ImmediatePriority:
      increment = -1;
      break;
    case NormalPriority:
    default:
      increment = 10000;
      break;
  }
  var task = {
    id: idCounter++,
    callback: callback,
    order: idCounter + increment
  };
  add$1(task);
  if (!isWaiting && !isProcessing) {
    isWaiting = true;
    requestBrowserCallback(callTasks);
  }
  return task;
}
function cancelTask(task) {
  task.callback = null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var renderQueue = null;
// 保存正在等待的异步Task，可以用于取消
var callingQueueTask = null;
// 防止重入
var isCallingRenderQueue = false;
function callRenderQueueImmediate() {
  if (callingQueueTask !== null) {
    // 取消异步调度
    cancelTask(callingQueueTask);
    callingQueueTask = null;
  }
  callRenderQueue$1();
}

// 执行render回调
function callRenderQueue$1() {
  if (!isCallingRenderQueue && renderQueue !== null) {
    // 防止重入
    isCallingRenderQueue = true;
    try {
      var callback;
      while (callback = renderQueue.shift()) {
        callback();
      }
      renderQueue = null;
    } catch (error) {
      throw error;
    } finally {
      isCallingRenderQueue = false;
    }
  }
}
function pushRenderCallback(callback) {
  if (renderQueue === null) {
    renderQueue = [callback];
    // 高优先级的异步调度
    callingQueueTask = runAsync(callRenderQueue$1, ImmediatePriority);
  } else {
    // 不需要调度，在syncQueue创建的时候已经调度了
    renderQueue.push(callback);
  }

  // 返回一个空对象，用于区别null
  return {};
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var VNode = /*#__PURE__*/_createClass(
// 节点所在代码位置

function VNode(tag, props, key, realNode) {
  _classCallCheck(this, VNode);
  this.tag = void 0;
  this.key = void 0;
  // 唯一标识符
  this.props = void 0;
  // 传给组件的props的值，类组件包含defaultProps，Lazy组件不包含
  this.type = null;
  this.realNode = void 0;
  // 如果是类，则存放实例；如果是div这种，则存放真实DOM；
  // 关系结构
  this.parent = null;
  // 父节点
  this.child = null;
  // 子节点
  this.next = null;
  // 兄弟节点
  this.cIndex = 0;
  // 节点在children数组中的位置
  this.eIndex = 0;
  // HorizonElement在jsx中的位置，例如：jsx中的null不会生成vNode，所以eIndex和cIndex不一致
  this.ref = null;
  // 包裹一个函数，submit阶段使用，比如将外部useRef生成的对象赋值到ref上
  this.oldProps = null;
  // 是否已经被从树上移除
  this.isCleared = false;
  this.changeList = void 0;
  // DOM的变更列表
  this.effectList = void 0;
  // useEffect 的更新数组
  this.updates = void 0;
  // TreeRoot和ClassComponent使用的更新数组
  this.stateCallbacks = void 0;
  // 存放存在setState的第二个参数和HorizonDOM.render的第三个参数所在的node数组
  this.isForceUpdate = void 0;
  // 是否使用强制更新
  this.isSuspended = false;
  // 是否被suspense打断更新
  this.state = void 0;
  // ClassComponent和TreeRoot的状态
  this.hooks = void 0;
  // 保存hook
  this.depContexts = void 0;
  // FunctionComponent和ClassComponent对context的依赖列表
  this.isDepContextChange = void 0;
  // context是否变更
  this.dirtyNodes = null;
  // 需要改动的节点数组
  this.shouldUpdate = false;
  this.childShouldUpdate = false;
  this.task = void 0;
  // 使用这个变量来记录修改前的值，用于恢复。
  this.context = void 0;
  // 因为LazyComponent会修改tag和type属性，为了能识别，增加一个属性
  this.isLazyComponent = void 0;
  // 因为LazyComponent会修改type属性，为了在diff中判断是否可以复用，需要增加一个lazyType
  this.lazyType = void 0;
  this.flags = InitFlag;
  this.clearChild = void 0;
  // one tree相关属性
  this.isCreated = true;
  this.oldHooks = void 0;
  // 保存上一次执行的hook
  this.oldState = void 0;
  this.oldRef = null;
  this.oldChild = null;
  this.promiseResolve = void 0;
  // suspense的promise是否resolve
  this.devProps = void 0;
  // 用于dev插件临时保存更新props值
  this.suspenseState = void 0;
  this.path = '';
  // 保存从根到本节点的路径
  // 根节点数据
  this.toUpdateNodes = void 0;
  // 保存要更新的节点
  this.delegatedEvents = void 0;
  this.belongClassVNode = null;
  // 记录JSXElement所属class vNode，处理ref的时候使用
  // 状态管理器HorizonX使用
  this.isStoreChange = void 0;
  this.observers = null;
  // 记录这个函数组件/类组件依赖哪些Observer
  this.classComponentWillUnmount = void 0;
  // HorizonX会在classComponentWillUnmount中清除对VNode的引入用
  this.src = void 0;
  this.tag = tag; // 对应组件的类型，比如ClassComponent等
  this.key = key;
  this.props = props;
  switch (tag) {
    case TreeRoot:
      this.realNode = realNode;
      this.task = null;
      this.toUpdateNodes = new Set();
      this.delegatedEvents = new Set();
      this.updates = null;
      this.stateCallbacks = null;
      this.state = null;
      this.oldState = null;
      this.context = null;
      break;
    case FunctionComponent:
      this.realNode = null;
      this.effectList = null;
      this.hooks = null;
      this.depContexts = null;
      this.isDepContextChange = false;
      this.oldHooks = null;
      this.isStoreChange = false;
      this.observers = null;
      this.classComponentWillUnmount = null;
      this.src = null;
      break;
    case ClassComponent:
      this.realNode = null;
      this.updates = null;
      this.stateCallbacks = null;
      this.isForceUpdate = false;
      this.state = null;
      this.depContexts = null;
      this.isDepContextChange = false;
      this.oldState = null;
      this.context = null;
      this.isStoreChange = false;
      this.observers = null;
      this.classComponentWillUnmount = null;
      this.src = null;
      break;
    case DomPortal:
      this.realNode = null;
      this.context = null;
      this.delegatedEvents = new Set();
      this.src = null;
      break;
    case DomComponent:
      this.realNode = null;
      this.changeList = null;
      this.context = null;
      this.src = null;
      break;
    case DomText:
      this.realNode = null;
      break;
    case SuspenseComponent:
      this.realNode = null;
      this.suspenseState = {
        promiseSet: null,
        didCapture: false,
        promiseResolved: false,
        oldChildStatus: '',
        childStatus: ''
      };
      this.src = null;
      break;
    case ContextProvider:
      this.src = null;
      this.context = null;
      break;
    case MemoComponent:
      this.effectList = null;
      this.src = null;
      break;
    case LazyComponent:
      this.realNode = null;
      this.stateCallbacks = null;
      this.isLazyComponent = true;
      this.lazyType = null;
      this.updates = null;
      this.src = null;
      break;
  }
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var PATH_DELIMITER = ',';

/**
 * 标记VNode在VNode树中的路径
 * @param vNode
 */
function markVNodePath(vNode) {
  vNode.path = "" + vNode.parent.path + PATH_DELIMITER + vNode.cIndex;
}
function getPathArr(vNode) {
  return vNode.path.split(PATH_DELIMITER);
}

var _typeLazyMap, _extends2;
var typeLazyMap = (_typeLazyMap = {}, _defineProperty(_typeLazyMap, TYPE_FORWARD_REF, ForwardRef), _defineProperty(_typeLazyMap, TYPE_MEMO, MemoComponent), _typeLazyMap);
var typeMap = _extends({}, typeLazyMap, (_extends2 = {}, _defineProperty(_extends2, TYPE_PROVIDER, ContextProvider), _defineProperty(_extends2, TYPE_CONTEXT, ContextConsumer), _defineProperty(_extends2, TYPE_LAZY, LazyComponent), _extends2));
function newVirtualNode(tag, key, vNodeProps, realNode) {
  var vNode = new VNode(tag, vNodeProps, key, realNode);
  return vNode;
}
function isClassComponent(comp) {
  var _comp$prototype;
  // 如果使用 getPrototypeOf 方法获取构造函数，不能兼容业务组组件继承组件的使用方式，会误认为是函数组件
  // 如果使用静态属性，部分函数高阶组件会将类组件的静态属性复制到自身，导致误判为类组件
  // 既然已经兼容使用了该标识符，那么继续使用
  return ((_comp$prototype = comp.prototype) === null || _comp$prototype === void 0 ? void 0 : _comp$prototype.isReactComponent) === true;
}

// 解析懒组件的tag
function getLazyVNodeTag(lazyComp) {
  if (typeof lazyComp === 'function') {
    return isClassComponent(lazyComp) ? ClassComponent : FunctionComponent;
  } else if (lazyComp !== undefined && lazyComp !== null && typeLazyMap[lazyComp.vtype]) {
    return typeLazyMap[lazyComp.vtype];
  }
  throw Error("Horizon can't resolve the content of lazy");
}

// 创建processing
function updateVNode(vNode, vNodeProps) {
  if (vNode.tag === ClassComponent) {
    vNode.oldState = vNode.state;
  }
  if (vNode.tag === SuspenseComponent) {
    vNode.suspenseState.oldChildStatus = vNode.suspenseState.childStatus;
    vNode.oldChild = vNode.child;
  }
  vNode.oldProps = vNode.props;
  vNode.props = vNodeProps;
  vNode.oldRef = vNode.ref;
  FlagUtils.setNoFlags(vNode);
  vNode.dirtyNodes = null;
  vNode.isCreated = false;
  return vNode;
}
function createFragmentVNode(fragmentKey, fragmentProps) {
  var vNode = newVirtualNode(Fragment, fragmentKey, fragmentProps);
  vNode.shouldUpdate = true;
  return vNode;
}
function createDomTextVNode(content) {
  var vNode = newVirtualNode(DomText, null, content);
  vNode.shouldUpdate = true;
  return vNode;
}
function createPortalVNode(portal) {
  var _portal$children;
  var children = (_portal$children = portal.children) !== null && _portal$children !== void 0 ? _portal$children : [];
  var vNode = newVirtualNode(DomPortal, portal.key, children);
  vNode.shouldUpdate = true;
  vNode.realNode = portal.realNode;
  return vNode;
}
function createUndeterminedVNode(type, key, props, source) {
  var vNodeTag = FunctionComponent;
  var isLazy = false;
  var componentType = typeof type;
  if (componentType === 'function') {
    if (isClassComponent(type)) {
      vNodeTag = ClassComponent;
    }
  } else if (componentType === 'string') {
    vNodeTag = DomComponent;
  } else if (type === TYPE_SUSPENSE) {
    vNodeTag = SuspenseComponent;
  } else if (componentType === 'object' && type !== null && typeMap[type.vtype]) {
    vNodeTag = typeMap[type.vtype];
    isLazy = type.vtype === TYPE_LAZY;
  } else {
    throw Error("Component type is invalid, got: " + (type == null ? type : componentType));
  }
  var vNode = newVirtualNode(vNodeTag, key, props);
  vNode.type = type;
  vNode.shouldUpdate = true;
  if (isLazy) {
    vNode.lazyType = type;
  }
  vNode.src = null;
  return vNode;
}
function getElementTag(element) {
  var type = element.type;
  if (type === TYPE_STRICT_MODE || type === TYPE_FRAGMENT || type === TYPE_PROFILER) {
    return Fragment;
  } else {
    var vNodeTag = FunctionComponent;
    var componentType = typeof type;
    if (componentType === 'function') {
      if (isClassComponent(type)) {
        vNodeTag = ClassComponent;
      }
    } else if (componentType === 'string') {
      vNodeTag = DomComponent;
    } else if (type === TYPE_SUSPENSE) {
      vNodeTag = SuspenseComponent;
    } else if (componentType === 'object' && type !== null && typeMap[type.vtype]) {
      vNodeTag = typeMap[type.vtype];
    }
    return vNodeTag;
  }
}
function createTreeRootVNode(container) {
  var vNode = newVirtualNode(TreeRoot, null, null, container);
  vNode.path = '0';
  vNode.updates = [];
  return vNode;
}
function createVNodeFromElement(element) {
  var type = element.type,
    key = element.key,
    props = element.props;
    element.src;
  if (type === TYPE_STRICT_MODE || type === TYPE_FRAGMENT || type === TYPE_PROFILER) {
    return createFragmentVNode(key, props.children);
  } else {
    return createUndeterminedVNode(type, key, props);
  }
}

// 直接更新子节点属性即可，不需要diff
function onlyUpdateChildVNodes(processing) {
  // 检查子树是否需要更新
  if (processing.childShouldUpdate) {
    // 此vNode无需更新，但是子树需要
    if (!processing.isCreated && processing.child !== null) {
      // 更新子节点
      var child = processing.child;
      while (child !== null) {
        updateVNode(child, child.props);
        markVNodePath(child);
        child = child.next;
      }
    }

    // 返回子节点，继续遍历
    return processing.child;
  }

  // 当跳过子树更新时，父节点path更新时，需要更新所有子树path
  if (processing.child && processing.path !== processing.child.path.slice(0, processing.path.length)) {
    // bfs更新子树path
    var queue = [];
    var putChildrenIntoQueue = function (vNode) {
      var child = vNode.child;
      if (child) {
        queue.push(child);
        var sibling = child.next;
        while (sibling) {
          queue.push(sibling);
          sibling = sibling.next;
        }
      }
    };
    putChildrenIntoQueue(processing);
    while (queue.length) {
      var vNode = queue.shift();
      markVNodePath(vNode);
      putChildrenIntoQueue(vNode);
    }
  }
  // 子树无需工作
  return null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var NSS = {
  html: 'http://www.w3.org/1999/xhtml',
  math: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

// 创建DOM元素
function createDom(tagName, parentNamespace, doc) {
  var dom;
  var selfNamespace = NSS[tagName] || NSS.html;
  var ns = parentNamespace !== NSS.html ? parentNamespace : selfNamespace;
  if (ns !== NSS.html) {
    dom = doc.createElementNS(ns, tagName);
  } else {
    dom = doc.createElement(tagName);
  }
  return dom;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 获取当前聚焦的 input 或者 textarea 元素
 * @param doc 指定 document
 */
function getFocusedDom(doc) {
  var _currentDocument$acti;
  var currentDocument = doc !== null && doc !== void 0 ? doc : document;
  return (_currentDocument$acti = currentDocument.activeElement) !== null && _currentDocument$acti !== void 0 ? _currentDocument$acti : currentDocument.body;
}

// 如果 input 或者 textarea 元素中有文字被选中时，activeElement 属性就会返回该元素
// 此处是为了返回深层的 iframe 中的真实元素
function getIFrameFocusedDom() {
  var currentWindow = window;
  var focusedDom = getFocusedDom();
  // 深度优先，返回的元素如果是 iframe 对象则继续查找
  while (focusedDom instanceof currentWindow.HTMLIFrameElement) {
    try {
      // 访问 HTMLIframeElement 的 contentDocument 可能会导致浏览器抛出错误
      if (typeof focusedDom.contentWindow.location.href === 'string') {
        // iframe 的内容为同源
        focusedDom = getFocusedDom(focusedDom.contentWindow.document);
      } else {
        // 非同源 iframe 因为安全性原因无法获取其中的具体元素
        break;
      }
    } catch (e) {
      // 非同源 iframe 因为安全性原因无法获取其中的具体元素
      break;
    }
  }
  return focusedDom;
}
function isElement$1(dom) {
  return dom.nodeType === 1;
}
function isText(dom) {
  return dom.nodeType === 3;
}
function isDocument(dom) {
  return dom.nodeType === 9;
}
function getDomTag(dom) {
  return dom.nodeName.toLowerCase();
}
var types = ['button', 'input', 'select', 'textarea'];

// button、input、select、textarea、如果有 autoFocus 属性需要focus
function shouldAutoFocus(tagName, props) {
  return types.includes(tagName) ? Boolean(props.autoFocus) : false;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 设置聚焦的 textarea 或 input 节点的选择范围
 * @param dom 需要设置选择范围的 input 或 textarea
 * @param range 选择范围对象
 */
function setSelectionRange(dom, range) {
  var start = range.start,
    end = range.end;
  var realEnd = end;
  if (realEnd == null) {
    realEnd = start;
  }
  if (typeof dom.setSelectionRange === 'function') {
    dom.setSelectionRange(start, realEnd);
  }
}

/**
 * 获取文本框、输入框中选中的文本的范围
 * @param dom 需要设置选择范围的 input 或 textarea
 * @return {start: selectionStart, end: selectionEnd}
 */
function getSelectionRange(dom) {
  var selectionRange = {
    start: 0,
    end: 0
  };
  if (!dom) {
    return selectionRange;
  }
  if ('selectionStart' in dom) {
    // 现代浏览器的 input 或 textarea 有 selectionStart 属性.
    selectionRange.start = dom.selectionStart;
    selectionRange.end = dom.selectionEnd;
  }
  return selectionRange;
}

// 判断第一个节点和另一个节点是否是包含关系
function isNodeContainsByTargetNode(targetNode, node) {
  if (!targetNode || !node) {
    return false;
  }
  if (targetNode === node) {
    return true;
  }
  if (isText(targetNode)) {
    return false;
  }
  if (isText(node)) {
    return isNodeContainsByTargetNode(targetNode, node.parentNode);
  }
  if (typeof targetNode.contains === 'function') {
    return targetNode.contains(node); // 该的节点是否为目标节点的后代节点
  }

  if (typeof targetNode.compareDocumentPosition === 'function') {
    // compareDocumentPosition 数值，表示两个节点彼此做比较的位置
    var CONTAINS_CODE = 16;
    // 返回 16 代表 第二节点在第一节点内部
    return targetNode.compareDocumentPosition(node) === CONTAINS_CODE;
  }
  return false;
}
function isInDocument(dom) {
  if (dom && dom.ownerDocument) {
    return isNodeContainsByTargetNode(dom.ownerDocument.documentElement, dom);
  }
  return false;
}

// 判断一个标签是否有设置选择范围的能力
function hasSelectionProperties(dom) {
  var elementType;
  if (dom && dom.nodeName) {
    elementType = dom.nodeName.toLowerCase();
    var validInputType = ['text', 'search', 'tel', 'url', 'password'];
    if (elementType === 'input') {
      return validInputType.includes(dom.type);
    } else if (elementType === 'textarea') {
      return dom.contentEditable === 'true';
    } else {
      return false;
    }
  } else {
    return false;
  }
}

// 返回当前 focus 的元素以及其选中的范围
function getSelectionInfo() {
  var focusedDom = getIFrameFocusedDom();
  return {
    focusedDom: focusedDom,
    selectionRange: hasSelectionProperties(focusedDom) ? getSelectionRange(focusedDom) : null
  };
}
// 防止选择范围内的信息因为节点删除或其他原因导致的信息丢失
function resetSelectionRange(preSelectionRangeData) {
  // 当前 focus 的元素
  var currentFocusedDom = getIFrameFocusedDom();

  // 先前 focus 的元素
  var preFocusedDom = preSelectionRangeData.focusedDom;
  if (!preFocusedDom) {
    return;
  }

  // 先前的选择范围信息
  var preSelectionRange = preSelectionRangeData.selectionRange;
  if (currentFocusedDom !== preFocusedDom && isInDocument(preFocusedDom)) {
    if (preSelectionRange !== null) {
      setSelectionRange(preFocusedDom, preSelectionRange);
    }

    // 滚动条位置可能会因为一个节点的选中变化位置，需要做处理
    var ancestors = [];
    var ancestor = preFocusedDom.parentNode;
    // 查找先前的 focus 节点的先祖
    while (ancestor) {
      if (isElement$1(ancestor)) {
        // 是元素节点，就把先祖信息放到先祖数组中
        // @ts-ignore
        var _ancestor = ancestor,
          scrollLeft = _ancestor.scrollLeft,
          scrollTop = _ancestor.scrollTop;
        ancestors.push({
          dom: ancestor,
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
        });
      }
      ancestor = ancestor.parentNode;
    }

    // 执行先前 focus 节点的 focus 方法
    if (typeof preFocusedDom.focus === 'function') {
      preFocusedDom.focus();
    }
    ancestors.forEach(function (ancestorInfo) {
      var ancestorDom = ancestorInfo.dom;
      ancestorDom.scrollLeft = ancestorInfo.scrollLeft;
      ancestorDom.scrollTop = ancestorInfo.scrollTop;
    });
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function isNeedUnitCSS(styleName) {
  return !(noUnitCSS.includes(styleName) || styleName.startsWith('borderImage') || styleName.startsWith('flex') || styleName.startsWith('gridRow') || styleName.startsWith('gridColumn') || styleName.startsWith('stroke') || styleName.startsWith('box') || styleName.endsWith('Opacity'));
}

/**
 * 对一些没有写单位的样式进行适配，例如：width: 10 => width: 10px
 * 对空值或布尔值进行适配，转为空字符串
 * 去掉多余空字符
 */
function adjustStyleValue(name, value) {
  var validValue = value;
  if (typeof value === 'number' && value !== 0 && isNeedUnitCSS(name)) {
    validValue = value + "px";
  } else if (value === '' || value == null || typeof value === 'boolean') {
    validValue = '';
  }
  return validValue;
}

/**
 * 设置 DOM 节点的 style 属性
 */
function setStyles(dom, styles) {
  if (!styles) {
    return;
  }
  if (Array.isArray(styles)) {
    styles.forEach(function (style) {
      setStyles(dom, style);
    });
    return;
  }
  var style = dom.style;
  Object.entries(styles).forEach(function (_ref) {
    var name = _ref[0],
      value = _ref[1];
    var styleVal = value;
    if (name.startsWith('--')) {
      style.setProperty(name, adjustStyleValue(name, styleVal));
    }
    style[name] = adjustStyleValue(name, styleVal);
  });
}

/**
 * 不需要加长度单位的 css 属性
 */
var noUnitCSS = ['animationIterationCount', 'columnCount', 'columns', 'gridArea', 'fontWeight', 'lineClamp', 'lineHeight', 'opacity', 'order', 'orphans', 'tabSize', 'widows', 'zIndex', 'zoom'];

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/* eslint-disable no-sparse-arrays */

// 属性值的数据类型
var PROPERTY_TYPE = /*#__PURE__*/function (PROPERTY_TYPE) {
  PROPERTY_TYPE[PROPERTY_TYPE["BOOLEAN"] = 0] = "BOOLEAN";
  PROPERTY_TYPE[PROPERTY_TYPE["STRING"] = 1] = "STRING";
  PROPERTY_TYPE[PROPERTY_TYPE["SPECIAL"] = 2] = "SPECIAL";
  PROPERTY_TYPE[PROPERTY_TYPE["BOOLEAN_STR"] = 3] = "BOOLEAN_STR";
  return PROPERTY_TYPE;
}({}); // 字符串类型的 true false
// 属性相关数据
// 依次为 propertyName、type、attributeName、attributeNamespace，不填则使用默认值
// type 默认 STRING
// attributeName 默认与 propertyName 相同
// attributeNamespace 默认 null
var propertiesData = [
// 一些特殊属性
['children', PROPERTY_TYPE.SPECIAL], ['dangerouslySetInnerHTML', PROPERTY_TYPE.SPECIAL], ['defaultValue', PROPERTY_TYPE.SPECIAL], ['defaultChecked', PROPERTY_TYPE.SPECIAL], ['innerHTML', PROPERTY_TYPE.SPECIAL], ['style', PROPERTY_TYPE.SPECIAL],
// propertyName 和 attributeName 不一样
['acceptCharset',, 'accept-charset'], ['className',, 'class'], ['htmlFor',, 'for'], ['httpEquiv',, 'http-equiv'],
// 字符串类型的 true false
['contentEditable', PROPERTY_TYPE.BOOLEAN_STR, 'contenteditable'], ['spellCheck', PROPERTY_TYPE.BOOLEAN_STR, 'spellcheck'], ['draggable', PROPERTY_TYPE.BOOLEAN_STR], ['value', PROPERTY_TYPE.BOOLEAN_STR],
// SVG 相关，字符串类型的 true false
['autoReverse', PROPERTY_TYPE.BOOLEAN_STR], ['externalResourcesRequired', PROPERTY_TYPE.BOOLEAN_STR], ['focusable', PROPERTY_TYPE.BOOLEAN_STR], ['preserveAlpha', PROPERTY_TYPE.BOOLEAN_STR],
// 布尔类型
['allowFullScreen', PROPERTY_TYPE.BOOLEAN, 'allowfullscreen'], ['async', PROPERTY_TYPE.BOOLEAN], ['autoFocus', PROPERTY_TYPE.BOOLEAN, 'autofocus'], ['autoPlay', PROPERTY_TYPE.BOOLEAN, 'autoplay'], ['controls', PROPERTY_TYPE.BOOLEAN], ['default', PROPERTY_TYPE.BOOLEAN], ['defer', PROPERTY_TYPE.BOOLEAN], ['disabled', PROPERTY_TYPE.BOOLEAN], ['disablePictureInPicture', PROPERTY_TYPE.BOOLEAN, 'disablepictureinpicture'], ['disableRemotePlayback', PROPERTY_TYPE.BOOLEAN, 'disableremoteplayback'], ['formNoValidate', PROPERTY_TYPE.BOOLEAN, 'formnovalidate'], ['hidden', PROPERTY_TYPE.BOOLEAN], ['loop', PROPERTY_TYPE.BOOLEAN], ['noModule', PROPERTY_TYPE.BOOLEAN, 'nomodule'], ['noValidate', PROPERTY_TYPE.BOOLEAN, 'novalidate'], ['open', PROPERTY_TYPE.BOOLEAN], ['playsInline', PROPERTY_TYPE.BOOLEAN, 'playsinline'], ['readOnly', PROPERTY_TYPE.BOOLEAN, 'readonly'], ['required', PROPERTY_TYPE.BOOLEAN], ['reversed', PROPERTY_TYPE.BOOLEAN], ['scoped', PROPERTY_TYPE.BOOLEAN], ['seamless', PROPERTY_TYPE.BOOLEAN], ['itemScope', PROPERTY_TYPE.BOOLEAN, 'itemscope'],
// 框架需要当做 property 来处理的，而不是 attribute 来处理的属性
['checked', PROPERTY_TYPE.BOOLEAN], ['multiple', PROPERTY_TYPE.BOOLEAN], ['muted', PROPERTY_TYPE.BOOLEAN], ['selected', PROPERTY_TYPE.BOOLEAN],
// SVG 属性
// xlink namespace 的 SVG 属性
['xlinkActuate',, 'xlink:actuate', 'http://www.w3.org/1999/xlink'], ['xlinkArcrole',, 'xlink:arcrole', 'http://www.w3.org/1999/xlink'], ['xlinkRole',, 'xlink:role', 'http://www.w3.org/1999/xlink'], ['xlinkShow',, 'xlink:show', 'http://www.w3.org/1999/xlink'], ['xlinkTitle',, 'xlink:title', 'http://www.w3.org/1999/xlink'], ['xlinkType',, 'xlink:type', 'http://www.w3.org/1999/xlink'],
// xml namespace 的 SVG 属性
['xmlBase',, 'xml:base', 'http://www.w3.org/XML/1998/namespace'], ['xmlLang',, 'xml:lang', 'http://www.w3.org/XML/1998/namespace'], ['xmlSpace',, 'xml:space', 'http://www.w3.org/XML/1998/namespace'],
// HTML and SVG 中都有的属性，大小写敏感
['tabIndex',, 'tabindex'], ['crossOrigin',, 'crossorigin'],
// 接受 URL 的属性
['xlinkHref',, 'xlink:href', 'http://www.w3.org/1999/xlink'], ['formAction',, 'formaction']];
var propsDetailData = {};
propertiesData.forEach(function (record) {
  var propName = record[0];
  var _record$slice = record.slice(1),
    type = _record$slice[0],
    attrName = _record$slice[1],
    attrNS = _record$slice[2];
  if (type === undefined) {
    type = PROPERTY_TYPE.STRING;
  }
  if (!attrName) {
    attrName = propName;
  }
  if (!attrNS) {
    attrNS = null;
  }
  propsDetailData[propName] = {
    propName: propName,
    type: type,
    attrName: attrName,
    attrNS: attrNS
  };
});
function getPropDetails(name) {
  return propsDetailData[name] || null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 是内置元素
function isNativeElement(tagName, props) {
  return !tagName.includes('-') && props.is === undefined;
}
function isInvalidBoolean(attributeName, value, propDetails) {
  if (propDetails.type === PROPERTY_TYPE.SPECIAL) {
    return false;
  }

  // 布尔值校验
  if (typeof value === 'boolean') {
    var isBooleanType = propDetails.type === PROPERTY_TYPE.BOOLEAN_STR || propDetails.type === PROPERTY_TYPE.BOOLEAN;
    if (isBooleanType || attributeName.startsWith('data-') && attributeName.startsWith('aria-')) {
      return false;
    }

    // 否则有问题
    return true;
  }
  return false;
}

// 是事件属性
function isEventProp(propName) {
  return propName.substr(0, 2) === 'on';
}
function isInvalidValue(name, value, propDetails, isNativeTag) {
  if (value == null) {
    return true;
  }
  if (!isNativeTag) {
    return false;
  }
  if (propDetails !== null && isInvalidBoolean(name, value, propDetails)) {
    return true;
  }
  if (propDetails !== null && propDetails.type === PROPERTY_TYPE.BOOLEAN) {
    return !value;
  }
  return false;
}

// dev模式下校验属性是否合法
function validateProps(type, props) {
  if (!props) {
    return;
  }

  // 非内置的变迁
  if (!isNativeElement(type, props)) {
    return;
  }

  // style属性必须是对象
  if (props.style != null && typeof props.style !== 'object') {
    try {
      var style = JSON.parse(props.style);
      if (typeof style === 'object') {
        props.style = style;
      } else throw new Error('style should be a object.');
    } catch (err) {
      throw new Error('style should be a object.');
    }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 不需要装换的svg属性集合
var svgHumpAttr = new Set();
['allowReorder', 'autoReverse', 'baseFrequency', 'baseProfile', 'calcMode', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'glyphRef', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform,', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'referrerPolicy', 'refX', 'refY', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget', 'xChannelSelector', 'yChannelSelector', 'zoomAndPan'].forEach(function (name) {
  return svgHumpAttr.add(name);
});

// 驼峰 变 “-”
function convertToLowerCase(str) {
  var replacer = function (match, char) {
    return "-" + char.toLowerCase();
  };
  return str.replace(/([A-Z])/g, replacer);
}

/**
 * 给 dom 设置属性
 * attrName 指代码中属性设置的属性名称（如 class）
 * 多数情况 attrName 仅用作初始 DOM 节点对象使用，而 property 更多用于页面交互
 */
function updateCommonProp(dom, attrName, value, isNativeTag) {
  var propDetails = getPropDetails(attrName);
  if (isInvalidValue(attrName, value, propDetails, isNativeTag)) {
    value = null;
  }
  if (attrName === '') {
    return;
  }
  if (!isNativeTag || propDetails === null) {
    // 特殊处理svg的属性，把驼峰式的属性名称转成'-'
    if (getDomTag(dom) === 'svg' || getNamespaceCtx() === NSS.svg) {
      if (!svgHumpAttr.has(attrName)) {
        attrName = convertToLowerCase(attrName);
      }
    }
    if (value === null) {
      dom.removeAttribute(attrName);
    } else if (typeof value === 'function') {
      dom.setAttribute(attrName, String(value()));
    } else {
      dom.setAttribute(attrName, String(value));
    }
  } else if (['checked', 'multiple', 'muted', 'selected'].includes(propDetails.attrName)) {
    if (value === null) {
      // 必填属性设置默认值
      dom[propDetails.attrName] = false;
    } else {
      dom[propDetails.attrName] = value;
    }
  } else {
    // 处理其他普通属性
    if (value === null) {
      dom.removeAttribute(propDetails.attrName);
    } else {
      var type = propDetails.type,
        attrNS = propDetails.attrNS; // 数据类型、固有属性命名空间
      var attributeName = propDetails.attrName; // 固有属性名
      var attributeValue;
      if (type === PROPERTY_TYPE.BOOLEAN) {
        // 即可以用作标志又可以是属性值的属性
        attributeValue = '';
      } else {
        attributeValue = String(value);
      }
      if (attrNS) {
        dom.setAttributeNS(attrNS, attributeName, attributeValue);
      } else {
        dom.setAttribute(attributeName, attributeValue);
      }
    }
  }
}

function getInitValue$1(dom, props) {
  var value = props.value,
    defaultValue = props.defaultValue,
    checked = props.checked,
    defaultChecked = props.defaultChecked;
  var defaultValueStr = defaultValue != null ? defaultValue : '';
  var initValue = value != null ? value : defaultValueStr;
  var initChecked = checked != null ? checked : defaultChecked;
  return {
    initValue: initValue,
    initChecked: initChecked
  };
}
function getInputPropsWithoutValue(dom, props) {
  // checked属于必填属性，无法置
  var checked = props.checked;
  if (checked == null) {
    checked = getInitValue$1(dom, props).initChecked;
  }
  return _extends({}, props, {
    value: undefined,
    defaultValue: undefined,
    defaultChecked: undefined,
    checked: checked
  });
}
function updateInputValue(dom, props) {
  var value = props.value,
    checked = props.checked;
  if (value != null) {
    // 处理 dom.value 逻辑
    if (dom.value !== String(value)) {
      dom.value = String(value);
    }
  } else if (checked != null) {
    updateCommonProp(dom, 'checked', checked, true);
  }
}

// 设置input的初始值
function setInitInputValue(dom, props) {
  var value = props.value,
    defaultValue = props.defaultValue;
  var _getInitValue = getInitValue$1(dom, props),
    initValue = _getInitValue.initValue,
    initChecked = _getInitValue.initChecked;
  if (value != null || defaultValue != null) {
    // value 的使用优先级 value 属性 > defaultValue 属性 > 空字符串
    var initValueStr = String(initValue);
    dom.value = initValueStr;
    dom.defaultValue = initValueStr;
  }

  // checked 的使用优先级 checked 属性 > defaultChecked 属性 > false
  dom.defaultChecked = Boolean(initChecked);
}

// 把 const a = 'a'; <option>gir{a}ffe</option> 转成 giraffe
function concatChildren(children) {
  var content = '';
  Children.forEach(children, function (child) {
    content += child;
  });
  return content;
}
function getOptionPropsWithoutValue(dom, props) {
  var content = concatChildren(props.children);
  return _extends({}, props, {
    children: content || undefined // 覆盖children
  });
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function updateMultipleValue(options, newValues) {
  var newValueSet = new Set();
  newValues.forEach(function (val) {
    newValueSet.add(String(val));
  });

  // options 非数组
  for (var i = 0; i < options.length; i++) {
    var option = options[i];
    var newValue = newValueSet.has(option.value);
    if (option.selected !== newValue) {
      option.selected = newValue;
    }
  }
}

// 单选时传入的选项参数必须是可以转为字符串的类型
function updateSingleValue(options, newValue) {
  for (var i = 0; i < options.length; i++) {
    var option = options[i];
    if (option.value === String(newValue)) {
      option.selected = true;
      break;
    }
  }
}

// 更新 <option>
function updateValue$1(options, newValues, isMultiple) {
  if (isMultiple) {
    updateMultipleValue(options, newValues);
  } else {
    updateSingleValue(options, newValues);
  }
}
function getSelectPropsWithoutValue(dom, properties) {
  return _extends({}, properties, {
    value: undefined
  });
}
function updateSelectValue(dom, props) {
  var isInit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var value = props.value,
    defaultValue = props.defaultValue,
    multiple = props.multiple;
  var oldMultiple = dom._multiple !== undefined ? dom._multiple : dom.multiple;
  var newMultiple = Boolean(multiple);
  dom._multiple = newMultiple;

  // 设置了 value 属性
  if (value != null) {
    updateValue$1(dom.options, value, newMultiple);
  } else if (oldMultiple !== newMultiple) {
    // 修改了 multiple 属性
    // 切换 multiple 之后，如果设置了 defaultValue 需要重新应用
    if (defaultValue != null) {
      updateValue$1(dom.options, defaultValue, newMultiple);
    } else {
      // 恢复到未选定状态
      updateValue$1(dom.options, newMultiple ? [] : '', newMultiple);
    }
  } else if (isInit && defaultValue != null) {
    // 设置了 defaultValue 属性
    updateValue$1(dom.options, defaultValue, newMultiple);
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 值的优先级 value > children > defaultValue
function getInitValue(props) {
  var value = props.value;
  if (value == null) {
    var defaultValue = props.defaultValue,
      children = props.children;
    var initValue = defaultValue;

    // children content存在时，会覆盖defaultValue
    if (children != null) {
      // 子节点不是纯文本，则取第一个子节点
      initValue = children instanceof Array ? children[0] : children;
    }

    // defaultValue 属性未配置，置为空字符串
    initValue = initValue != null ? initValue : '';
    return initValue;
  } else {
    return value;
  }
}
function getTextareaPropsWithoutValue(dom, properties) {
  return _extends({}, properties, {
    value: undefined
  });
}
function updateTextareaValue(dom, props) {
  var isInit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (isInit) {
    var initValue = getInitValue(props);
    if (initValue !== '') {
      dom.value = initValue;
    }
  } else {
    // 获取当前节点的 value 值
    var value = props.value;
    if (value != null) {
      value = String(value);
      // 当且仅当值实际发生变化时才去设置节点的value值
      if (dom.value !== value) {
        dom.value = value;
      }
    }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 获取元素除了被代理的值以外的属性
function getPropsWithoutValue(type, dom, props) {
  switch (type) {
    case 'input':
      return getInputPropsWithoutValue(dom, props);
    case 'option':
      return getOptionPropsWithoutValue(dom, props);
    case 'select':
      return getSelectPropsWithoutValue(dom, props);
    case 'textarea':
      return getTextareaPropsWithoutValue(dom, props);
    default:
      return props;
  }
}

// 其它属性挂载完成后处理被代理值相关的属性
function setInitValue(type, dom, props) {
  switch (type) {
    case 'input':
      setInitInputValue(dom, props);
      break;
    case 'select':
      updateSelectValue(dom, props, true);
      break;
    case 'textarea':
      updateTextareaValue(dom, props, true);
      break;
  }
}

// 更新需要适配的属性
function updateValue(type, dom, props) {
  switch (type) {
    case 'input':
      updateInputValue(dom, props);
      break;
    case 'select':
      updateSelectValue(dom, props);
      break;
    case 'textarea':
      updateTextareaValue(dom, props);
      break;
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 需要委托的horizon事件和原生事件对应关系
var allDelegatedHorizonEvents = new Map();
// 所有委托的原生事件集合
var allDelegatedNativeEvents = new Set();

// Horizon事件和原生事件对应关系
var horizonEventToNativeMap = new Map([['onKeyPress', ['keypress']], ['onTextInput', ['textInput']], ['onClick', ['click']], ['onDoubleClick', ['dblclick']], ['onFocus', ['focusin']], ['onBlur', ['focusout']], ['onInput', ['input']], ['onWheel', ['wheel']], ['onMouseOut', ['mouseout']], ['onMouseOver', ['mouseover']], ['onPointerOut', ['pointerout']], ['onPointerOver', ['pointerover']], ['onContextMenu', ['contextmenu']], ['onDragEnd', ['dragend']], ['onKeyDown', ['keydown']], ['onKeyUp', ['keyup']], ['onMouseDown', ['mousedown']], ['onMouseMove', ['mousemove']], ['onMouseUp', ['mouseup']], ['onSelectChange', ['selectionchange']], ['onTouchEnd', ['touchend']], ['onTouchMove', ['touchmove']], ['onTouchStart', ['touchstart']], ['onCompositionEnd', ['compositionend']], ['onCompositionStart', ['compositionstart']], ['onCompositionUpdate', ['compositionupdate']], ['onChange', ['change', 'click', 'focusout', 'input']], ['onSelect', ['select']], ['onAnimationEnd', ['animationend']], ['onAnimationIteration', ['animationiteration']], ['onAnimationStart', ['animationstart']], ['onTransitionEnd', ['transitionend']]]);
var NativeEventToHorizonMap = {
  click: 'click',
  wheel: 'wheel',
  dblclick: 'doubleClick',
  contextmenu: 'contextMenu',
  dragend: 'dragEnd',
  focusin: 'focus',
  focusout: 'blur',
  input: 'input',
  select: 'select',
  keydown: 'keyDown',
  keypress: 'keyPress',
  keyup: 'keyUp',
  mousedown: 'mouseDown',
  mouseup: 'mouseUp',
  touchend: 'touchEnd',
  touchstart: 'touchStart',
  mousemove: 'mouseMove',
  mouseout: 'mouseOut',
  mouseover: 'mouseOver',
  pointermove: 'pointerMove',
  pointerout: 'pointerOut',
  pointerover: 'pointerOver',
  selectionchange: 'selectChange',
  textInput: 'textInput',
  touchmove: 'touchMove',
  animationend: 'animationEnd',
  animationiteration: 'animationIteration',
  animationstart: 'animationStart',
  transitionend: 'transitionEnd',
  compositionstart: 'compositionStart',
  compositionend: 'compositionEnd',
  compositionupdate: 'compositionUpdate'
};
var EVENT_TYPE_BUBBLE = 'Bubble';
var EVENT_TYPE_CAPTURE = 'Capture';
var EVENT_TYPE_ALL = 'All';
horizonEventToNativeMap.forEach(function (dependencies, horizonEvent) {
  allDelegatedHorizonEvents.set(horizonEvent, dependencies);
  allDelegatedHorizonEvents.set(horizonEvent + 'Capture', dependencies);
  dependencies.forEach(function (d) {
    allDelegatedNativeEvents.add(d);
  });
});
function transformToHorizonEvent(nativeEvtName) {
  var name = NativeEventToHorizonMap[nativeEvtName];
  // 例：dragEnd -> onDragEnd
  return !name ? '' : "on" + name[0].toUpperCase() + name.slice(1);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function isInputElement(dom) {
  return dom instanceof HTMLInputElement || dom instanceof HTMLTextAreaElement;
}
function setPropertyWritable(obj, propName) {
  var desc = Object.getOwnPropertyDescriptor(obj, propName);
  if (!desc || !desc.writable) {
    Object.defineProperty(obj, propName, {
      writable: true
    });
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 兼容IE的event key

var uniqueKeyMap = new Map([['Esc', 'Escape'], ['Spacebar', ' '], ['Left', 'ArrowLeft'], ['Up', 'ArrowUp'], ['Right', 'ArrowRight'], ['Down', 'ArrowDown'], ['Del', 'Delete']]);
var noop = function () {};

// 兼容IE浏览器，无法修改Event属性
var WrappedEvent = /*#__PURE__*/function () {
  function WrappedEvent(customEventName, nativeEvtName, nativeEvent) {
    var _this = this,
      _key;
    _classCallCheck(this, WrappedEvent);
    this.customEventName = void 0;
    this.nativeEvent = void 0;
    this.nativeEventType = void 0;
    this.type = void 0;
    this.key = void 0;
    this.currentTarget = null;
    this.stopPropagation = void 0;
    this.preventDefault = void 0;
    this.propagationStopped = false;
    this.isPropagationStopped = function () {
      return _this.propagationStopped;
    };
    // 适配Keyboard键盘事件该函数不能由合成事件调用
    this.getModifierState = void 0;
    // 适配老版本事件api
    this.persist = noop;
    for (var name in nativeEvent) {
      this[name] = nativeEvent[name];
      if (name === 'getModifierState') {
        (function () {
          var keyBoardEvent = nativeEvent;
          _this.getModifierState = function (keyArg) {
            return keyBoardEvent.getModifierState(keyArg);
          };
        })();
      }
    }
    // stopPropagation和preventDefault 必须通过Event实例调用
    this.stopPropagation = function () {
      nativeEvent.stopPropagation();
      _this.propagationStopped = true;
    };
    this.preventDefault = function () {
      return nativeEvent.preventDefault();
    };

    // custom事件自定义属性
    this.customEventName = customEventName;
    this.nativeEvent = nativeEvent;
    // 保存原生的事件类型，因为下面会修改
    this.nativeEventType = nativeEvent.type;
    this.type = nativeEvtName;

    // 兼容IE的event key
    var orgKey = (_key = nativeEvent.key) !== null && _key !== void 0 ? _key : '';
    this.key = uniqueKeyMap.get(orgKey) || orgKey;
  }
  _createClass(WrappedEvent, [{
    key: "isDefaultPrevented",
    value: function isDefaultPrevented() {
      return this.nativeEvent.defaultPrevented;
    }
  }]);
  return WrappedEvent;
}();

// 创建普通自定义事件对象实例，和原生事件对应
function decorateNativeEvent(customEventName, nativeEvtName, nativeEvent) {
  return new WrappedEvent(customEventName, nativeEvtName, nativeEvent);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 从vnode属性中获取事件listener
function getListenerFromVNode(vNode, eventName) {
  var props = vNode.props;
  var mouseEvents = ['onClick', 'onDoubleClick', 'onMouseDown', 'onMouseMove', 'onMouseUp', 'onMouseEnter'];
  var formElements = ['button', 'input', 'select', 'textarea'];

  // 是否应该阻止禁用的表单元素触发鼠标事件
  var shouldPreventMouseEvent = mouseEvents.includes(eventName) && props.disabled && formElements.includes(vNode.type);
  var listener = props[eventName];
  if (shouldPreventMouseEvent) {
    return null;
  } else {
    return listener;
  }
}

// 获取监听事件
function getListenersFromTree(targetVNode, horizonEvtName, nativeEvent, eventType) {
  if (!horizonEvtName) {
    return [];
  }
  var listeners = [];
  var vNode = targetVNode;

  // 从目标节点到根节点遍历获取listener
  while (vNode !== null) {
    var _vNode = vNode,
      realNode = _vNode.realNode,
      tag = _vNode.tag;
    if (tag === DomComponent && realNode !== null) {
      if (eventType === EVENT_TYPE_ALL || eventType === EVENT_TYPE_CAPTURE) {
        var captureName = horizonEvtName + EVENT_TYPE_CAPTURE;
        var captureListener = getListenerFromVNode(vNode, captureName);
        if (captureListener) {
          listeners.unshift({
            vNode: vNode,
            listener: captureListener,
            currentTarget: realNode,
            event: nativeEvent
          });
        }
      }
      if (eventType === EVENT_TYPE_ALL || eventType === EVENT_TYPE_BUBBLE) {
        var bubbleListener = getListenerFromVNode(vNode, horizonEvtName);
        if (bubbleListener) {
          listeners.push({
            vNode: vNode,
            listener: bubbleListener,
            currentTarget: realNode,
            event: nativeEvent
          });
        }
      }
    }
    vNode = vNode.parent;
  }
  return listeners;
}

function omit(obj, attrs) {
  Object.fromEntries(Object.entries(obj).filter(function (_ref) {
    var key = _ref[0];
      _ref[1];
    return !attrs.includes(key);
  }));
}
registerComponent('component', function (props) {
  return createElement.apply(void 0, [props.is, omit(props, ['children', 'is'])].concat(props.children));
});

var _executeMode;
/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var ByAsync = 'BY_ASYNC';
var BySync = 'BY_SYNC';
var InRender = 'IN_RENDER';
var InEvent = 'IN_EVENT';
// 当前执行模式标记
var executeMode = (_executeMode = {}, _defineProperty(_executeMode, ByAsync, false), _defineProperty(_executeMode, BySync, false), _defineProperty(_executeMode, InRender, false), _defineProperty(_executeMode, InEvent, false), _executeMode);
function changeMode(mode) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  executeMode[mode] = state;
}
function checkMode(mode) {
  return executeMode[mode];
}
function isExecuting() {
  return executeMode[ByAsync] || executeMode[BySync] || executeMode[InRender] || executeMode[InEvent];
}
function copyExecuteMode() {
  return _extends({}, executeMode);
}
function setExecuteMode(mode) {
  executeMode = mode;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var EffectConstant = {
  NoEffect: 0,
  DepsChange: 1,
  // dependence发生了改变
  LayoutEffect: 2,
  // 同步触发的effect
  Effect: 4,
  // 异步触发的effect
  RenderEffect: 8
};

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var hookEffects = [];
var hookRemoveEffects = [];
// 是否正在异步调度effects
var isScheduling = false;
function setSchedulingEffects(value) {
  isScheduling = value;
}
function isSchedulingEffects() {
  return isScheduling;
}
function callUseEffects(vNode) {
  var effectList = vNode.effectList;
  if (effectList !== null) {
    effectList.forEach(function (effect) {
      var effectConstant = effect.effectConstant;
      if ((effectConstant & EffectConstant.Effect) !== EffectConstant.NoEffect && (effectConstant & EffectConstant.DepsChange) !== EffectConstant.NoEffect) {
        hookEffects.push(effect);
        hookRemoveEffects.push(effect);

        // 异步调用
        if (!isScheduling) {
          isScheduling = true;
          runAsync(runAsyncEffects);
        }
      }
    });
  }
}

// render effects are called immediatelly after element is rendered and befor it is mounted
function callRenderEffects(vNode) {
  var effectList = vNode.effectList;
  if (effectList !== null) {
    effectList.forEach(function (effect) {
      var effectConstant = effect.effectConstant;
      if ((effectConstant & EffectConstant.RenderEffect) !== EffectConstant.NoEffect && (effectConstant & EffectConstant.DepsChange) !== EffectConstant.NoEffect) {
        effect.effect();
      }
    });
  }
}
function runAsyncEffects() {
  var preMode = copyExecuteMode();
  changeMode(InRender, true);

  // 调用effect destroy
  var removeEffects = hookRemoveEffects;
  hookRemoveEffects = [];
  removeEffects.forEach(function (effect) {
    var destroy = effect.removeEffect;
    effect.removeEffect = undefined;
    if (typeof destroy === 'function') {
      try {
        destroy();
      } catch (error) {
        // 不处理副作用阶段抛出的异常
      }
    }
  });

  // 调用effect create
  var createEffects = hookEffects;
  hookEffects = [];
  createEffects.forEach(function (effect) {
    try {
      var create = effect.effect;
      effect.removeEffect = create();
    } catch (error) {
      // 不处理副作用阶段抛出的异常
    }
  });
  setExecuteMode(preMode);
}

// 在销毁vNode的时候调用remove
function callEffectRemove(vNode) {
  var effectList = vNode.effectList;
  if (effectList !== null) {
    effectList.forEach(function (effect) {
      var removeEffect = effect.removeEffect,
        effectConstant = effect.effectConstant;
      if (removeEffect !== undefined) {
        if ((effectConstant & EffectConstant.Effect) !== EffectConstant.NoEffect) {
          // 如果是useEffect，就异步调用
          hookRemoveEffects.push(effect);
          if (!isScheduling) {
            isScheduling = true;
            runAsync(runAsyncEffects);
          }
        } else {
          // 是useLayoutEffect，直接执行
          removeEffect();
        }
      }
    });
  }
}

// 同步执行UseLayoutEffect的remove
function callUseLayoutEffectRemove(vNode) {
  var effectList = vNode.effectList;
  var layoutLabel = EffectConstant.LayoutEffect | EffectConstant.DepsChange;
  if (effectList !== null) {
    effectList.forEach(function (effect) {
      if ((effect.effectConstant & layoutLabel) === layoutLabel) {
        var remove = effect.removeEffect;
        effect.removeEffect = undefined;
        if (typeof remove === 'function') {
          remove();
        }
      }
    });
  }
}

// 同步执行UseLayoutEffect
function callUseLayoutEffectCreate(vNode) {
  var effectList = vNode.effectList;
  if (effectList !== null) {
    var layoutLabel = EffectConstant.LayoutEffect | EffectConstant.DepsChange;
    effectList.forEach(function (effect) {
      if ((effect.effectConstant & layoutLabel) === layoutLabel) {
        var create = effect.effect;
        effect.removeEffect = create();
      }
    });
  }
}

var UpdateState = /*#__PURE__*/function (UpdateState) {
  UpdateState["Update"] = "Update";
  UpdateState["Override"] = "Override";
  UpdateState["ForceUpdate"] = "ForceUpdate";
  UpdateState["Error"] = "Error";
  return UpdateState;
}({});

// 创建update对象
function newUpdate() {
  return {
    type: UpdateState.Update,
    // 更新的类型
    content: null,
    // ClassComponent的content是setState第一个参数，TreeRoot的content是HorizonDOM.render的第一个参数
    callback: null // setState的第二个参数，HorizonDOM.render的第三个参数
  };
}

// 将update对象加入updates
function pushUpdate(vNode, update) {
  var updates = vNode.updates;
  if (updates !== null) {
    updates.push(update);
  } else {
    vNode.updates = [update];
  }
}

// 根据update获取新的state
function calcState(vNode, update, inst, oldState, props) {
  switch (update.type) {
    case UpdateState.Override:
      var content = update.content;
      return typeof content === 'function' ? content.call(inst, oldState, props) : content;
    case UpdateState.ForceUpdate:
      vNode.isForceUpdate = true;
      return oldState;
    case UpdateState.Error:
      FlagUtils.removeFlag(vNode, ShouldCapture);
      FlagUtils.markDidCapture(vNode);
    case UpdateState.Update:
      var updateContent = update.content;
      var newState = typeof updateContent === 'function' ? updateContent.call(inst, oldState, props) : updateContent;
      return newState === null || newState === undefined ? oldState : _extends({}, oldState, newState);
    default:
      return oldState;
  }
}

// 收集callback
function collectCallbacks(vNode, update) {
  if (update.callback !== null) {
    FlagUtils.markCallback(vNode);
    if (vNode.stateCallbacks === null) {
      vNode.stateCallbacks = [update.callback];
    } else {
      vNode.stateCallbacks.push(update.callback);
    }
  }
}

// 遍历处理updates, 更新vNode的state
function calcUpdates(vNode, props, inst, toProcessUpdates) {
  var newState = vNode.state;
  toProcessUpdates.forEach(function (update) {
    newState = calcState(vNode, update, inst, newState, props);
    collectCallbacks(vNode, update);
  });
  vNode.shouldUpdate = false;
  vNode.state = newState;
}

// 将待更新的队列，添加到updates的尾部
function processUpdates(vNode, inst, props) {
  var updates = vNode.updates;
  vNode.isForceUpdate = false;
  if (updates !== null) {
    var toProcessUpdates = [].concat(updates);
    updates.length = 0;
    if (toProcessUpdates.length) {
      calcUpdates(vNode, props, inst, toProcessUpdates);
    }
  }
}
function pushForceUpdate(vNode) {
  var update = newUpdate();
  update.type = UpdateState.ForceUpdate;
  pushUpdate(vNode, update);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createPortal(children, realNode) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return {
    vtype: TYPE_PORTAL,
    key: key == '' ? '' : '' + key,
    children: children,
    realNode: realNode
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function startUpdate(element, treeRoot, callback) {
  var update = newUpdate();
  update.content = {
    element: element
  };
  if (typeof callback === 'function') {
    update.callback = callback;
  }
  pushUpdate(treeRoot, update);
  launchUpdateFromVNode(treeRoot);
}
function getFirstCustomDom(treeRoot) {
  if (treeRoot !== null && treeRoot !== void 0 && treeRoot.child) {
    return treeRoot.child.realNode;
  }
  return null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * Horizon的输入框和文本框的change事件在原生的change事件上做了一层处理
 * 只有值发生变化时才会触发change事件。
 */

var HANDLER_KEY = '_valueChangeHandler';

// 判断是否是 check 类型
function isCheckType(dom) {
  var type = dom.type,
    nodeName = dom.nodeName;
  if (nodeName && nodeName.toLowerCase() === 'input') {
    return type === 'checkbox' || type === 'radio';
  }
  return false;
}

/**
 * value值发生变化时，执行value的getter、setter。
 * 事件触发时，判断currentVal 和 input 的真实值是否一致，从而判断是否实际变更，
 * 只有发生变更了，事件处理才会生成一个change事件
 */
function watchValueChange(dom) {
  if (!dom[HANDLER_KEY]) {
    // check: 复选框、单选框; value: 输入框、文本框等
    var keyForValue = isCheckType(dom) ? 'checked' : 'value';
    // 获取 value 属性的描述信息，其 value 在其 constructor 的 原型上
    var descriptor = Object.getOwnPropertyDescriptor(dom.constructor.prototype, keyForValue);
    if (Object.prototype.hasOwnProperty.call(dom, keyForValue)) {
      return;
    }

    // currentVal存储最新值，并重写value的setter、getter
    var currentVal = String(dom[keyForValue]);
    var setFunc = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;
    Object.defineProperty(dom, keyForValue, _extends({}, descriptor, {
      set: function (value) {
        currentVal = String(value);
        setFunc === null || setFunc === void 0 ? void 0 : setFunc.apply(this, [value]);
      }
    }));
    dom[HANDLER_KEY] = {
      getValue: function () {
        return currentVal;
      },
      setValue: function (value) {
        currentVal = String(value);
      }
    };
  }
}

// 更新input dom的handler 状态，返回是否更新
function updateInputHandlerIfChanged(dom) {
  var handler = dom[HANDLER_KEY];
  if (!handler) {
    return true;
  }
  var newValue;
  if (isCheckType(dom)) {
    newValue = dom.checked ? 'true' : 'false';
  } else {
    newValue = dom.value;
  }
  var oldValue = handler.getValue();
  if (newValue !== oldValue) {
    handler.setValue(newValue);
    return true;
  }
  return false;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 记录表单控件 input/textarea/select的onChange事件的targets
var changeEventTargets = null;

// 存储队列中缓存组件
function recordChangeEventTargets(target) {
  if (changeEventTargets) {
    changeEventTargets.push(target);
  } else {
    changeEventTargets = [target];
  }
}

// 判断是否需要控制value与props保持一致
function shouldControlValue() {
  return changeEventTargets !== null && changeEventTargets.length > 0;
}

// 从缓存队列中对受控组件进行赋值
function tryControlValue() {
  if (!changeEventTargets) {
    return;
  }
  changeEventTargets.forEach(function (target) {
    controlValue(target);
  });
  changeEventTargets = null;
}

// 受控组件值重新赋值
function controlValue(target) {
  var props = getVNodeProps(target);
  if (props) {
    var type = getDomTag(target);
    switch (type) {
      case 'input':
        controlInputValue(target, props);
        break;
      case 'textarea':
        updateTextareaValue(target, props);
        break;
    }
  }
}
function controlInputValue(inputDom, props) {
  var name = props.name,
    type = props.type;

  // 如果是 radio，找出同一form内，name相同的Radio，更新它们Handler的Value
  if (type === 'radio' && name != null) {
    var radioList = document.querySelectorAll("input[type=\"radio\"][name=\"" + name + "\"]");
    for (var i = 0; i < radioList.length; i++) {
      var radio = radioList[i];
      if (radio === inputDom) {
        continue;
      }
      if (radio.form != null && inputDom.form != null && radio.form !== inputDom.form) {
        continue;
      }
      updateInputHandlerIfChanged(radio);
    }
  } else {
    updateInputValue(inputDom, props);
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// web规范，鼠标右键key值
var RIGHT_MOUSE_BUTTON = 2;

// 返回是否需要触发change事件标记
// | 元素 | 事件 |  需要值变更 |
// | --- | ---  | ---------------  |
// | <select/> / <input type="file/> | change | NO |
// | <input type="checkbox" /> <input type="radio" /> | click | YES |
// | <input type="input /> / <input type="text" /> | input / change | YES |
function shouldTriggerChangeEvent(targetDom, evtName) {
  var type = targetDom.type;
  var domTag = getDomTag(targetDom);
  if (domTag === 'select' || domTag === 'input' && type === 'file') {
    return evtName === 'change';
  } else if (domTag === 'input' && (type === 'checkbox' || type === 'radio')) {
    if (evtName === 'click') {
      return updateInputHandlerIfChanged(targetDom);
    }
  } else if (isInputElement(targetDom)) {
    if (evtName === 'input' || evtName === 'change') {
      return updateInputHandlerIfChanged(targetDom);
    }
  }
  return false;
}

/**
 *
 * 支持input/textarea/select的onChange事件
 */
function getChangeListeners(nativeEvtName, nativeEvt, vNode, target) {
  if (!vNode) {
    return [];
  }
  var targetDom = getDom(vNode);

  // 判断是否需要触发change事件
  if (shouldTriggerChangeEvent(targetDom, nativeEvtName)) {
    recordChangeEventTargets(target);
    var event = decorateNativeEvent('onChange', 'change', nativeEvt);
    return getListenersFromTree(vNode, 'onChange', event, EVENT_TYPE_ALL);
  }
  return [];
}

// 获取事件触发的普通事件监听方法队列
function getCommonListeners(nativeEvtName, vNode, nativeEvent, target, isCapture) {
  var horizonEvtName = transformToHorizonEvent(nativeEvtName);
  if (!horizonEvtName) {
    return [];
  }

  // 鼠标点击右键
  if (nativeEvent instanceof MouseEvent && nativeEvtName === 'click' && nativeEvent.button === RIGHT_MOUSE_BUTTON) {
    return [];
  }
  if (nativeEvtName === 'focusin') {
    nativeEvtName = 'focus';
  }
  if (nativeEvtName === 'focusout') {
    nativeEvtName = 'blur';
  }
  var horizonEvent = decorateNativeEvent(horizonEvtName, nativeEvtName, nativeEvent);
  return getListenersFromTree(vNode, horizonEvtName, horizonEvent, isCapture ? EVENT_TYPE_CAPTURE : EVENT_TYPE_BUBBLE);
}

// 按顺序执行事件队列
function processListeners(listenerList) {
  listenerList.forEach(function (eventUnit) {
    var currentTarget = eventUnit.currentTarget,
      listener = eventUnit.listener,
      event = eventUnit.event;
    if (event.isPropagationStopped()) {
      return;
    }
    setPropertyWritable(event, 'currentTarget');
    event.currentTarget = currentTarget;
    listener(event);
    event.currentTarget = null;
  });
}

// 触发可以被执行的horizon事件监听
function triggerHorizonEvents(nativeEvtName, isCapture, nativeEvent, vNode) {
  var target = nativeEvent.target || nativeEvent.srcElement;
  if (nativeEvtName === 'click' && nativeEvent.detail > 1) {
    var dblClickListeners = getCommonListeners('dblClick', vNode, nativeEvent, target, isCapture);
    if (dblClickListeners.length > 0) nativeEvtName = 'dblClick';
  }

  // 触发普通委托事件
  var listenerList = getCommonListeners(nativeEvtName, vNode, nativeEvent, target, isCapture);

  // 触发特殊handler委托事件
  if (!isCapture && horizonEventToNativeMap.get('onChange').includes(nativeEvtName)) {
    var changeListeners = getChangeListeners(nativeEvtName, nativeEvent, vNode, target);
    if (changeListeners.length) {
      listenerList = listenerList.concat(changeListeners);
    }
  }

  // 处理触发的事件队列
  processListeners(listenerList);
}

// 其他事件正在执行中标记
var isInEventsExecution = false;

// 处理委托事件入口
function handleEventMain(nativeEvtName, isCapture, nativeEvent, vNode, targetDom) {
  var startVNode = vNode;
  if (startVNode !== null) {
    startVNode = findRoot(startVNode, targetDom);
    if (!startVNode) {
      return;
    }
  }

  // 有事件正在执行，同步执行事件
  if (isInEventsExecution) {
    triggerHorizonEvents(nativeEvtName, isCapture, nativeEvent, startVNode);
    return;
  }

  // 没有事件在执行，经过调度再执行事件
  isInEventsExecution = true;
  try {
    asyncUpdates(function () {
      return triggerHorizonEvents(nativeEvtName, isCapture, nativeEvent, startVNode);
    });
  } finally {
    isInEventsExecution = false;
    if (shouldControlValue()) {
      runDiscreteUpdates();
      tryControlValue();
    }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
'_horizonListening' + Math.random().toString(36).slice(4);

// 触发委托事件
function triggerDelegatedEvent(nativeEvtName, isCapture, targetDom, nativeEvent // 事件对象event
) {
  // 执行之前的调度事件
  runDiscreteUpdates();
  var nativeEventTarget = nativeEvent.target || nativeEvent.srcElement;
  var targetVNode = getNearestVNode(nativeEventTarget);
  handleEventMain(nativeEvtName, isCapture, nativeEvent, targetVNode, targetDom);
}

// 监听委托事件
function listenToNativeEvent(nativeEvtName, delegatedElement, isCapture) {
  var dom = delegatedElement;
  // document层次可能触发selectionchange事件，为了捕获这类事件，selectionchange事件绑定在document节点上
  if (nativeEvtName === 'selectionchange' && !isDocument(delegatedElement)) {
    dom = delegatedElement.ownerDocument;
  }
  var listener = triggerDelegatedEvent.bind(null, nativeEvtName, isCapture, dom);
  dom.addEventListener(nativeEvtName, listener, isCapture);
  return listener;
}

// 事件懒委托，当用户定义事件后，再进行委托到根节点
function lazyDelegateOnRoot(currentRoot, eventName) {
  currentRoot.delegatedEvents.add(eventName);
  var isCapture = isCaptureEvent(eventName);
  var nativeEvents = allDelegatedHorizonEvents.get(eventName);
  nativeEvents.forEach(function (nativeEvent) {
    var nativeFullName = isCapture ? nativeEvent + 'capture' : nativeEvent;

    // 事件存储在DOM节点属性，避免多个VNode(root和portal)对应同一个DOM, 造成事件重复监听
    var events = currentRoot.realNode.$EV;
    if (!events) {
      events = currentRoot.realNode.$EV = {};
    }
    if (!events[nativeFullName]) {
      var listener = listenToNativeEvent(nativeEvent, currentRoot.realNode, isCapture);
      events[nativeFullName] = listener;
    }
  });
}

// 通过horizon事件名获取到native事件名
function getNativeEvtName(horizonEventName, capture) {
  var nativeName;
  if (capture) {
    nativeName = horizonEventName.slice(2, -7);
  } else {
    nativeName = horizonEventName.slice(2);
  }
  if (!nativeName) {
    return '';
  }
  return nativeName.toLowerCase();
}

// 是否捕获事件
function isCaptureEvent(horizonEventName) {
  if (horizonEventName === 'onLostPointerCapture' || horizonEventName === 'onGotPointerCapture') {
    return false;
  }
  return horizonEventName.slice(-7) === 'Capture';
}

// 封装监听函数
function getWrapperListener(horizonEventName, nativeEvtName, targetElement, listener) {
  return function (event) {
    var customEvent = decorateNativeEvent(horizonEventName, nativeEvtName, event);
    asyncUpdates(function () {
      listener(customEvent);
    });
  };
}

// 非委托事件单独监听到各自dom节点
function listenNonDelegatedEvent(horizonEventName, domElement, listener) {
  var isCapture = isCaptureEvent(horizonEventName);
  var nativeEvtName = getNativeEvtName(horizonEventName, isCapture);

  // 先判断是否存在老的监听事件，若存在则移除
  var nonDelegatedListenerMap = getNonDelegatedListenerMap(domElement);
  var currentListener = nonDelegatedListenerMap.get(horizonEventName);
  if (currentListener) {
    domElement.removeEventListener(nativeEvtName, currentListener);
    nonDelegatedListenerMap.delete(horizonEventName);
  }
  if (typeof listener !== 'function') {
    return;
  }

  // 为了和委托事件对外行为一致，将事件对象封装成CustomBaseEvent
  var wrapperListener = getWrapperListener(horizonEventName, nativeEvtName, domElement, listener);
  // 添加新的监听
  nonDelegatedListenerMap.set(horizonEventName, wrapperListener);
  domElement.addEventListener(nativeEvtName, wrapperListener, isCapture);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var currentRootStack = [];
function getCurrentRoot() {
  return currentRootStack[currentRootStack.length - 1];
}
function pushCurrentRoot(root) {
  return currentRootStack.push(root);
}
function popCurrentRoot() {
  return currentRootStack.pop();
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 初始化DOM属性和更新 DOM 属性
function setDomProps(dom, props, isNativeTag, isInit) {
  var keysOfProps = Object.keys(props);
  var propName;
  var propVal;
  var keyLength = keysOfProps.length;
  for (var i = 0; i < keyLength; i++) {
    propName = keysOfProps[i];
    propVal = props[propName];
    if (propName === 'style') {
      setStyles(dom, propVal);
    } else if (isEventProp(propName)) {
      // 事件监听属性处理
      var currentRoot = getCurrentRoot();
      if (!allDelegatedHorizonEvents.has(propName)) {
        listenNonDelegatedEvent(propName, dom, propVal);
      } else if (currentRoot && !currentRoot.delegatedEvents.has(propName)) {
        lazyDelegateOnRoot(currentRoot, propName);
      }
    } else if (propName === 'className' && typeof propVal !== 'string') {
      (function () {
        var classesToAdd = [];
        var classesToRemove = [];
        if (Array.isArray(propVal)) {
          propVal.forEach(function (val) {
            if (!val) return;
            if (typeof val === 'string') {
              dom.classList.add(val);
            } else if (typeof val === 'object') {
              Object.entries(val).forEach(function (_ref) {
                var className = _ref[0],
                  shouldRender = _ref[1];
                if (shouldRender) {
                  classesToAdd.push(className);
                } else {
                  classesToRemove.push(className);
                }
              });
            }
          });
        } else if (typeof propVal === 'object') {
          var _dom$classList, _dom$classList2;
          Object.entries(propVal).forEach(function (_ref2) {
            var className = _ref2[0],
              shouldRender = _ref2[1];
            if (shouldRender) {
              classesToAdd.push(className);
            } else {
              classesToRemove.push(className);
            }
          });
          (_dom$classList = dom.classList).add.apply(_dom$classList, classesToAdd);
          classesToRemove.forEach(function (cssClass) {
            if (dom.classList.contains(cssClass)) {
              dom.classList.remove(cssClass);
            }
          });
          (_dom$classList2 = dom.classList).remove.apply(_dom$classList2, classesToRemove);
        }
      })();
    } else if (propName === 'children') {
      // 只处理纯文本子节点，其他children在VNode树中处理
      var type = typeof propVal;
      if (type === 'string' || type === 'number') {
        dom.textContent = propVal;
      }
    } else if (propName === 'dangerouslySetInnerHTML') {
      setTimeout(function (html) {
        dom.innerHTML = html;
      }.bind(null, propVal.__html), 0);
    } else if (!isInit || isInit && propVal != null) {
      updateCommonProp(dom, propName, propVal, isNativeTag);
    }
  }
}

// 找出两个 DOM 属性的差别，生成需要更新的属性集合
function compareProps(oldProps, newProps) {
  var updatesForStyle = {};
  var toUpdateProps = {};
  var keysOfOldProps = Object.keys(oldProps);
  var keysOfNewProps = Object.keys(newProps);
  var oldPropsLength = keysOfOldProps.length;
  var propName;
  var oldStyle;
  var styleProps;
  var styleProp;
  // 找到旧属性中需要删除的属性
  for (var i = 0; i < oldPropsLength; i++) {
    propName = keysOfOldProps[i];
    // 新属性中包含该属性或者该属性为空值的属性不需要处理
    if (keysOfNewProps.includes(propName) || oldProps[propName] == null) {
      continue;
    }
    if (propName === 'style') {
      oldStyle = oldProps[propName];
      styleProps = Object.keys(oldStyle);
      for (var j = 0; j < styleProps.length; j++) {
        styleProp = styleProps[j];
        updatesForStyle[styleProp] = '';
      }
    } else if (propName === 'autoFocus' || propName === 'children' || propName === 'dangerouslySetInnerHTML') {
      continue;
    } else if (isEventProp(propName)) {
      if (!allDelegatedHorizonEvents.has(propName)) {
        toUpdateProps[propName] = null;
      }
    } else {
      // 其它属性都要加入到删除队列里面，等待删除
      toUpdateProps[propName] = null;
    }
  }
  var newPropValue;
  var oldPropValue;
  var oldStyleProps;
  var newStyleProps;
  var newHTML;
  var oldHTML;
  // 遍历新属性，获取新增和变更属性
  for (var _i = 0; _i < keysOfNewProps.length; _i++) {
    propName = keysOfNewProps[_i];
    newPropValue = newProps[propName];
    oldPropValue = oldProps != null ? oldProps[propName] : null;
    if (newPropValue === oldPropValue || newPropValue == null && oldPropValue == null) {
      // 新旧属性值未发生变化，或者新旧属性皆为空值，不需要进行处理
      continue;
    }
    if (propName === 'style') {
      if (oldPropValue) {
        // 之前 style 属性有设置非空值
        // 原来有这个 style，但现在没这个 style 了
        oldStyleProps = Object.keys(oldPropValue);
        for (var _j = 0; _j < oldStyleProps.length; _j++) {
          styleProp = oldStyleProps[_j];
          if (!newPropValue || !Object.prototype.hasOwnProperty.call(newPropValue, styleProp)) {
            updatesForStyle[styleProp] = '';
          }
        }

        // 现在有这个 style，但是和原来不相等
        newStyleProps = newPropValue ? Object.keys(newPropValue) : [];
        for (var _j2 = 0; _j2 < newStyleProps.length; _j2++) {
          styleProp = newStyleProps[_j2];
          if (oldPropValue[styleProp] !== newPropValue[styleProp]) {
            updatesForStyle[styleProp] = newPropValue[styleProp];
          }
        }
      } else {
        // 之前未设置 style 属性或者设置了空值
        if (Object.keys(updatesForStyle).length === 0) {
          toUpdateProps[propName] = null;
        }
        updatesForStyle = newPropValue;
      }
    } else if (propName === 'dangerouslySetInnerHTML') {
      newHTML = newPropValue ? newPropValue.__html : undefined;
      oldHTML = oldPropValue ? oldPropValue.__html : undefined;
      if (newHTML != null) {
        if (oldHTML !== newHTML) {
          toUpdateProps[propName] = newPropValue;
        }
      }
    } else if (propName === 'children') {
      if (typeof newPropValue === 'string' || typeof newPropValue === 'number') {
        toUpdateProps[propName] = String(newPropValue);
      }
    } else if (isEventProp(propName)) {
      var currentRoot = getCurrentRoot();
      if (!allDelegatedHorizonEvents.has(propName)) {
        toUpdateProps[propName] = newPropValue;
      } else if (currentRoot && !currentRoot.delegatedEvents.has(propName)) {
        lazyDelegateOnRoot(currentRoot, propName);
      }
    } else {
      toUpdateProps[propName] = newPropValue;
    }
  }

  // 处理style
  if (Object.keys(updatesForStyle).length > 0) {
    toUpdateProps['style'] = updatesForStyle;
  }
  return toUpdateProps;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var selectionInfo = null;
function getChildNS(parentNS, tagName) {
  if (parentNS === NSS.svg && tagName === 'foreignObject') {
    return NSS.html;
  }
  if (parentNS == null || parentNS === NSS.html) {
    var _NSS$tagName;
    // 没有父命名空间，或父命名空间为xhtml
    return (_NSS$tagName = NSS[tagName]) !== null && _NSS$tagName !== void 0 ? _NSS$tagName : NSS.html;
  }

  // 默认返回parentNamespace.
  return parentNS;
}

// 获取容器
function getNSCtx(parentNS, type, dom) {
  var _dom$namespaceURI;
  return dom ? getChildNS((_dom$namespaceURI = dom.namespaceURI) !== null && _dom$namespaceURI !== void 0 ? _dom$namespaceURI : null, dom.nodeName) : getChildNS(parentNS, type);
}
function prepareForSubmit() {
  selectionInfo = getSelectionInfo();
}
function resetAfterSubmit() {
  resetSelectionRange(selectionInfo);
  selectionInfo = null;
}

// 创建 DOM 对象
function newDom(tagName, props, parentNamespace, vNode) {
  // document取值于treeRoot对应的DOM的ownerDocument。
  // 解决：在iframe中使用top的horizon时，horizon在创建DOM时用到的document并不是iframe的document，而是top中的document的问题。
  var rootDom = getCurrentRoot().realNode;
  var doc = isDocument(rootDom) ? rootDom : rootDom.ownerDocument;
  var dom = createDom(tagName, parentNamespace, doc);
  // 将 vNode 节点挂到 DOM 对象上
  saveVNode(vNode, dom);
  // 将属性挂到 DOM 对象上
  updateVNodeProps(dom, props);
  return dom;
}

// 设置节点默认事件、属性
function initDomProps(dom, tagName, rawProps) {
  validateProps(tagName, rawProps);

  // 获取不包括value，defaultValue的属性
  var props = getPropsWithoutValue(tagName, dom, rawProps);

  // 初始化DOM属性（不包括value，defaultValue）
  var isNativeTag = isNativeElement(tagName, props);
  setDomProps(dom, props, isNativeTag, true);
  if (tagName === 'input' || tagName === 'textarea') {
    // 增加监听value和checked的set、get方法
    watchValueChange(dom);
  }

  // 设置dom.value值，触发受控组件的set方法
  setInitValue(tagName, dom, rawProps);
  return shouldAutoFocus(tagName, rawProps);
}

// 准备更新之前进行一系列校验 DOM，寻找属性差异等准备工作
function getPropChangeList(dom, type, lastRawProps, nextRawProps) {
  // 校验两个对象的不同
  validateProps(type, nextRawProps);

  // 重新定义的属性不需要参与对比，被代理的组件需要把这些属性覆盖到props中
  var oldProps = getPropsWithoutValue(type, dom, lastRawProps);
  var newProps = getPropsWithoutValue(type, dom, nextRawProps);
  return compareProps(oldProps, newProps);
}
function isTextChild(type, props) {
  if (type === 'textarea' || type === 'option' || type === 'noscript') {
    return true;
  }
  var childType = typeof props.children;
  if (childType === 'string' || childType === 'number') {
    return true;
  } else {
    return props.dangerouslySetInnerHTML && typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML.__html != null;
  }
}
function newTextDom(text, processing) {
  var textNode = document.createTextNode(text);
  saveVNode(processing, textNode);
  return textNode;
}

// 提交vNode的类型为Component或者Text的更新
function submitDomUpdate(tag, vNode) {
  var newProps = vNode.props;
  var element = vNode.realNode;
  if (tag === DomComponent) {
    // DomComponent类型
    if (element != null) {
      var type = vNode.type;
      var changeList = vNode.changeList;
      vNode.changeList = null;
      if (changeList !== null) {
        saveVNode(vNode, element);
        updateVNodeProps(element, newProps);
        // 应用diff更新Properties.
        // 当一个选中的radio改变名称,浏览器使另一个radio的复选框为false.
        if (type === 'input' && newProps.type === 'radio' && newProps.name != null && newProps.checked != null) {
          updateCommonProp(element, 'checked', newProps.checked, true);
        }
        var isNativeTag = isNativeElement(type, newProps);
        setDomProps(element, changeList, isNativeTag, false);
        updateValue(type, element, newProps);
      }
    }
  } else if (tag === DomText) {
    if (element != null) {
      // text类型
      element.textContent = newProps;
    }
  }
}
function clearText(dom) {
  dom.innerHTML = '';
}

// 添加child元素
function appendChildElement(parent, child) {
  parent.appendChild(child);
}

// 插入dom元素
function insertDomBefore(parent, child, beforeChild) {
  parent.insertBefore(child, beforeChild);
}
function removeChildDom(parent, child) {
  parent.removeChild(child);
}

// 隐藏元素
function hideDom(tag, dom) {
  if (tag === DomComponent) {
    dom.style.display = 'none';
  } else if (tag === DomText) {
    dom.textContent = '';
  }
}

// 不隐藏元素
function unHideDom(tag, dom, props) {
  if (tag === DomComponent) {
    var _props$style$display, _props$style;
    dom.style.display = adjustStyleValue('display', (_props$style$display = props === null || props === void 0 ? void 0 : (_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.display) !== null && _props$style$display !== void 0 ? _props$style$display : '');
  } else if (tag === DomText) {
    dom.textContent = props;
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 保存的是“http://www.w3.org/1999/xhtml”或“http://www.w3.org/2000/svg”，
// 用于识别是使用document.createElement()还是使用document.createElementNS()创建DOM
var ctxNamespace = '';

// capture阶段设置
function setNamespaceCtx(vNode, dom) {
  var nextContext = getNSCtx(ctxNamespace, vNode.type, dom);
  vNode.context = ctxNamespace;
  ctxNamespace = nextContext;
}

// bubble阶段恢复
function resetNamespaceCtx(vNode) {
  ctxNamespace = vNode.context;
}
function getNamespaceCtx() {
  return ctxNamespace;
}
function setContext(providerVNode, nextValue) {
  var context = providerVNode.type._context;
  providerVNode.context = context.value;
  context.value = nextValue;
}
function resetContext(providerVNode) {
  var context = providerVNode.type._context;
  context.value = providerVNode.context;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// hooks阶段
var HookStage = /*#__PURE__*/function (HookStage) {
  HookStage[HookStage["Init"] = 1] = "Init";
  HookStage[HookStage["Update"] = 2] = "Update";
  return HookStage;
}({});
var hookStage = null;
function getHookStage() {
  return hookStage;
}
function setHookStage(phase) {
  hookStage = phase;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// lastTimeHook是上一次执行func时产生的hooks中，与currentHook对应的hook
var lastTimeHook = null;

// 当前hook函数对应的hook对象
var currentHook = null;
function getLastTimeHook() {
  return lastTimeHook;
}
function setLastTimeHook(hook) {
  lastTimeHook = hook;
}
function setCurrentHook(hook) {
  currentHook = hook;
}
function throwNotInFuncError() {
  throw Error('Hooks should be used inside function component.');
}

// 新建一个hook，并放到vNode.hooks中
function createHook() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var processingVNode = getProcessingVNode();
  var newHook = {
    state: state,
    hIndex: processingVNode.hooks.length
  };
  currentHook = newHook;
  processingVNode.hooks.push(newHook);
  return currentHook;
}
function getNextHook(hook, hooks) {
  return hooks[hook.hIndex + 1] || null;
}

// 获取当前hook函数对应的hook对象。
// processing中的hook和上一次执行中的hook，需要同时往前走，
// 原因：1.比对hook的数量有没有变化（非必要）；2.从上一次执行中的hook获取removeEffect
function getCurrentHook() {
  var processingVNode = getProcessingVNode();
  currentHook = currentHook !== null ? getNextHook(currentHook, processingVNode.hooks) : processingVNode.hooks[0] || null;
  if (lastTimeHook !== null) {
    lastTimeHook = getNextHook(lastTimeHook, processingVNode.oldHooks);
  } else {
    if (processingVNode.oldHooks && processingVNode.oldHooks.length) {
      lastTimeHook = processingVNode.oldHooks[0];
    } else {
      lastTimeHook = null;
    }
  }
  if (currentHook === null) {
    if (lastTimeHook === null) {
      throw Error('Hooks are more than expected, please check whether the hook is written in the condition.');
    }
    createHook(lastTimeHook.state);
  }
  return currentHook;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 重置依赖
function resetDepContexts(vNode) {
  vNode.depContexts = null;
}

// 收集依赖
function collectDeps(vNode, context) {
  var depContexts = vNode.depContexts;
  if (depContexts === null) {
    vNode.depContexts = [context];
  } else {
    vNode.isDepContextChange = false;
    if (!depContexts.includes(context)) {
      depContexts.push(context);
    }
  }
}
function getNewContext(vNode, ctx) {
  var isUseContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // 如果来自于useContext，则需要在函数组件中调用
  if (isUseContext && getHookStage() === null) {
    throwNotInFuncError();
  }

  // 调用到这个方法，说明当前vNode依赖了这个context，所以需要收集起来
  collectDeps(vNode, ctx);
  return ctx.value;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// hook对外入口
function runFunctionWithHooks(funcComp, props, arg, processing) {
  // 重置全局变量
  resetGlobalVariable();
  processing.oldHooks = processing.hooks;
  processing.hooks = [];
  processing.effectList = [];

  // 设置hook阶段
  if (processing.isCreated || !processing.oldHooks.length) {
    setHookStage(HookStage.Init);
  } else {
    setHookStage(HookStage.Update);
  }
  var comp = funcComp(props, arg);

  // 设置hook阶段为null，用于判断hook是否在函数组件中调用
  setHookStage(null);

  // 判断hook是否写在了if条件中，如果在if中会出现数量不对等的情况
  var lastTimeHook = getLastTimeHook();
  if (lastTimeHook !== null) {
    if (getNextHook(getLastTimeHook(), processing.oldHooks) !== null) {
      throw Error('Hooks are less than expected, please check whether the hook is written in the condition.');
    }
  }

  // 重置全局变量
  resetGlobalVariable();
  return comp;
}
function resetGlobalVariable() {
  setHookStage(null);
  setLastTimeHook(null);
  setCurrentHook(null);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 当前vNode和element是同样的类型
// LazyComponent 会修改type的类型，所以特殊处理这种类型
var isSameType = function (vNode, ele) {
  return vNode.type === ele.type || vNode.isLazyComponent && vNode.lazyType === ele.type;
};
function isTextType(newChild) {
  return typeof newChild === 'string' || typeof newChild === 'number';
}
function isIteratorType(newChild) {
  return typeof Symbol === 'function' && newChild[Symbol.iterator] || newChild['@@iterator'];
}
function getIteratorFn(maybeIterable) {
  return maybeIterable[Symbol.iterator] || maybeIterable['@@iterator'];
}
function isObjectType(newChild) {
  return typeof newChild === 'object' && newChild !== null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var DiffCategory = /*#__PURE__*/function (DiffCategory) {
  DiffCategory["TEXT_NODE"] = "TEXT_NODE";
  DiffCategory["OBJECT_NODE"] = "OBJECT_NODE";
  DiffCategory["ARR_NODE"] = "ARR_NODE";
  return DiffCategory;
}(DiffCategory || {}); // 检查是不是被 FRAGMENT 包裹
function isNoKeyFragment(child) {
  return child != null && child.type === TYPE_FRAGMENT && child.key === null;
}

// 清除单个节点
function deleteVNode(parentNode, delVNode) {
  FlagUtils.setDeletion(delVNode);
  if (parentNode.dirtyNodes === null) {
    parentNode.dirtyNodes = [delVNode];
    return;
  }
  parentNode.dirtyNodes.push(delVNode);
}

// 清除多个节点
function deleteVNodes(parentVNode, startDelVNode, endVNode) {
  var node = startDelVNode;
  while (node !== null) {
    if (node === endVNode) {
      return;
    }
    deleteVNode(parentVNode, node);
    node = node.next;
  }
}
function checkCanReuseNode(oldNode, newChild, newNodeIdx) {
  if (newChild === null) {
    return false;
  }
  var oldKey = oldNode !== null ? oldNode.key : null;
  if (isTextType(newChild)) {
    return oldKey === null;
  }
  if (isObjectType(newChild)) {
    if (Array.isArray(newChild) || isIteratorType(newChild)) {
      return oldKey === null;
    }
    if (newChild.vtype === TYPE_COMMON_ELEMENT || newChild.vtype === TYPE_PORTAL) {
      // key存在时用key判断复用
      if (oldKey !== null || newChild.key !== null) {
        return oldKey === newChild.key;
      } else {
        // 新旧节点的index应该相同才能复用，null会影响位置
        return (oldNode === null || oldNode === void 0 ? void 0 : oldNode.eIndex) === newNodeIdx;
      }
    }
  }
  return false;
}
function getNodeType(newChild) {
  if (newChild === null) {
    return null;
  }
  if (isTextType(newChild)) {
    return DiffCategory.TEXT_NODE;
  }
  if (isObjectType(newChild)) {
    if (Array.isArray(newChild) || isIteratorType(newChild)) {
      return DiffCategory.ARR_NODE;
    }
    if (newChild.vtype === TYPE_COMMON_ELEMENT || newChild.vtype === TYPE_PORTAL) {
      return DiffCategory.OBJECT_NODE;
    }
  }
  return null;
}

// 设置vNode的flag
function setVNodeAdditionFlag(newNode, lastPosition) {
  var position = lastPosition;
  if (newNode.isCreated || newNode.eIndex < lastPosition) {
    // 位置 小于 上一个复用的位置
    // 标记为新增
    FlagUtils.setAddition(newNode);
  } else {
    // 复用
    position = newNode.eIndex;
  }
  return position;
}

// 获取新节点
function getNewNode(parentNode, newChild, oldNode) {
  var newNodeType = getNodeType(newChild);
  if (newNodeType === null) {
    return null;
  }
  var resultNode = null;
  switch (newNodeType) {
    case DiffCategory.TEXT_NODE:
      {
        if (oldNode === null || oldNode.tag !== DomText) {
          resultNode = createDomTextVNode(String(newChild));
        } else {
          resultNode = updateVNode(oldNode, String(newChild));
        }
        break;
      }
    case DiffCategory.ARR_NODE:
      {
        if (oldNode === null || oldNode.tag !== Fragment) {
          resultNode = createFragmentVNode(null, newChild);
        } else {
          resultNode = updateVNode(oldNode, newChild);
        }
        break;
      }
    case DiffCategory.OBJECT_NODE:
      {
        if (newChild.vtype === TYPE_COMMON_ELEMENT) {
          if (newChild.type === TYPE_FRAGMENT) {
            if (oldNode === null || oldNode.tag !== Fragment) {
              var key = oldNode !== null ? oldNode.key : newChild.key;
              resultNode = createFragmentVNode(key, newChild.props.children);
            } else {
              resultNode = updateVNode(oldNode, newChild);
            }
            break;
          }
          if (oldNode === null || !isSameType(oldNode, newChild)) {
            resultNode = createVNodeFromElement(newChild);
            resultNode.ref = newChild.ref;
            resultNode.belongClassVNode = newChild.belongClassVNode;
          } else {
            resultNode = updateVNode(oldNode, newChild.props);
            resultNode.ref = newChild.ref;
            resultNode.belongClassVNode = newChild.belongClassVNode;
          }
          break;
        } else if (newChild.vtype === TYPE_PORTAL) {
          if (oldNode === null || oldNode.tag !== DomPortal || oldNode.realNode !== newChild.realNode) {
            resultNode = createPortalVNode(newChild);
          } else {
            resultNode = updateVNode(oldNode, newChild.children || []);
          }
          break;
        }
      }
  }
  if (resultNode) {
    resultNode.parent = parentNode;
    resultNode.next = null;
  }
  return resultNode;
}
function transRightChildrenToArray(child) {
  var rightChildrenArray = [];
  travelChildren(child, function (node) {
    rightChildrenArray.push(node);
  });
  return rightChildrenArray;
}
function transLeftChildrenToMap(startChild, rightEndVNode) {
  var leftChildrenMap = new Map();
  travelChildren(startChild, function (node) {
    leftChildrenMap.set(node.key !== null ? node.key : node.eIndex, node);
  }, function (node) {
    return node === rightEndVNode;
  });
  return leftChildrenMap;
}
function getOldNodeFromMap(nodeMap, newIdx, newChild) {
  if (isTextType(newChild)) {
    return nodeMap.get(newIdx) || null;
  }
  if (isObjectType(newChild)) {
    if (Array.isArray(newChild) || isIteratorType(newChild)) {
      return nodeMap.get(newIdx) || null;
    }
    if (newChild.vtype === TYPE_COMMON_ELEMENT || newChild.vtype === TYPE_PORTAL) {
      return nodeMap.get(newChild.key === null ? newIdx : newChild.key) || null;
    }
  }
  return null;
}

// diff数组类型的节点，核心算法
function diffArrayNodesHandler(parentNode, firstChild, newChildren) {
  var resultingFirstChild = null;
  var prevNewNode = null;
  var oldNode = firstChild;
  var nextOldNode = null;
  var theLastPosition = 0;
  // 从左边开始的位置
  var leftIdx = 0;
  function appendNode(newNode) {
    if (prevNewNode === null) {
      resultingFirstChild = newNode;
      newNode.cIndex = 0;
    } else {
      prevNewNode.next = newNode;
      newNode.cIndex = prevNewNode.cIndex + 1;
    }
    markVNodePath(newNode);
    prevNewNode = newNode;
  }
  var canBeReuse;
  var newNode;
  // 1. 从左侧开始比对currentVNode和newChildren，若不能复用则跳出循环
  for (; oldNode !== null && leftIdx < newChildren.length; leftIdx++) {
    if (oldNode.eIndex > leftIdx) {
      // 当新旧节点位置不一，则将缓存当前的旧节点，放到下一次对比
      nextOldNode = oldNode;
      oldNode = null;
    } else {
      nextOldNode = oldNode.next;
    }
    canBeReuse = checkCanReuseNode(oldNode, newChildren[leftIdx], leftIdx);
    // 不能复用，break
    if (!canBeReuse) {
      var _oldNode;
      oldNode = (_oldNode = oldNode) !== null && _oldNode !== void 0 ? _oldNode : nextOldNode;
      break;
    }
    newNode = getNewNode(parentNode, newChildren[leftIdx], oldNode);
    // 没有生成新节点，break
    if (!newNode) {
      var _oldNode2;
      oldNode = (_oldNode2 = oldNode) !== null && _oldNode2 !== void 0 ? _oldNode2 : nextOldNode;
      break;
    }

    // diff过程中，需要将现有的节点清除掉，如果是创建，则不需要处理（因为没有现存节点）
    if (oldNode && newNode.isCreated) {
      deleteVNode(parentNode, oldNode);
    }
    theLastPosition = setVNodeAdditionFlag(newNode, theLastPosition);
    newNode.eIndex = leftIdx;
    appendNode(newNode);
    oldNode = nextOldNode;
  }
  var rightIdx = newChildren.length;
  var rightEndOldNode; // 老节点中最右边匹配的节点引用 abcde --> abfde 则rightEndOldNode = c;
  var rightNewNode = null; // 最右边匹配的节点引用 abcde --> abfde 则rightNewNode = d;
  // 从后往前，新资源的位置还没有到最末端，旧的vNode也还没遍历完，则可以考虑从后往前开始
  if (rightIdx > leftIdx && oldNode !== null) {
    var rightRemainingOldChildren = transRightChildrenToArray(oldNode);
    var rightOldIndex = rightRemainingOldChildren.length - 1;

    // 2. 从右侧开始比对currentVNode和newChildren，若不能复用则跳出循环
    var rightOldNode;
    for (; rightIdx > leftIdx; rightIdx--) {
      rightOldNode = rightRemainingOldChildren[rightOldIndex];
      if (rightOldIndex < 0 || rightOldNode === null) {
        break;
      }
      canBeReuse = checkCanReuseNode(rightOldNode, newChildren[rightIdx - 1], rightIdx - 1);
      // 不能复用，break
      if (!canBeReuse) {
        break;
      }
      newNode = getNewNode(parentNode, newChildren[rightIdx - 1], rightOldNode);
      // 没有生成新节点，break
      if (newNode === null) {
        break;
      }

      // 链接起来
      if (rightNewNode === null) {
        rightNewNode = newNode;
      } else {
        newNode.next = rightNewNode;
        rightNewNode = newNode;
      }
      if (rightOldNode && newNode.isCreated) {
        deleteVNode(parentNode, rightOldNode);
      }
      setVNodeAdditionFlag(newNode, theLastPosition);
      newNode.eIndex = rightIdx - 1;
      rightOldIndex--;
      rightEndOldNode = rightOldNode;
    }
  }

  // 3. 新节点已经处理完成
  if (leftIdx === rightIdx) {
    if (firstChild && parentNode.tag === DomComponent && newChildren.length === 0) {
      FlagUtils.markClear(parentNode);
      parentNode.clearChild = firstChild;
    } else {
      deleteVNodes(parentNode, oldNode, rightEndOldNode);
    }
    if (rightNewNode) {
      appendNode(rightNewNode);
      setVNodesCIndex(rightNewNode, prevNewNode.cIndex + 1);
    }
    return resultingFirstChild;
  }

  // 4. 新节点还有一部分，但是老节点已经没有了
  if (oldNode === null) {
    var _parentNode$oldProps, _parentNode$oldProps$;
    var isDirectAdd = false;
    // TODO: 是否可以扩大至非dom类型节点
    // 如果dom节点在上次添加前没有节点，说明本次添加时，可以直接添加到最后，不需要通过 getSiblingDom 函数找到 before 节点
    if (parentNode.tag === DomComponent && ((_parentNode$oldProps = parentNode.oldProps) === null || _parentNode$oldProps === void 0 ? void 0 : (_parentNode$oldProps$ = _parentNode$oldProps.children) === null || _parentNode$oldProps$ === void 0 ? void 0 : _parentNode$oldProps$.length) === 0 && rightIdx - leftIdx === newChildren.length) {
      isDirectAdd = true;
    }
    var isAddition = parentNode.tag === DomPortal || !parentNode.isCreated;
    for (; leftIdx < rightIdx; leftIdx++) {
      newNode = getNewNode(parentNode, newChildren[leftIdx], null);
      if (newNode !== null) {
        if (isAddition) {
          FlagUtils.setAddition(newNode);
        }
        if (isDirectAdd) {
          FlagUtils.markDirectAddition(newNode);
        }
        newNode.eIndex = leftIdx;
        appendNode(newNode);
      }
    }
    if (rightNewNode) {
      appendNode(rightNewNode);
      setVNodesCIndex(rightNewNode.next, rightNewNode.cIndex + 1);
    }
    return resultingFirstChild;
  }

  // 5. 新节点还有一部分，但是老节点也还有一部分
  // 把剩下的currentVNode转成Map
  var leftChildrenMap = transLeftChildrenToMap(oldNode, rightEndOldNode);
  // 通过贪心算法+二分法获取最长递增子序列
  var eIndexes = []; // 记录 eIndex 值
  var result = []; // 记录最长子序列在eIndexes中的 index 值
  var preIndex = []; // 贪心算法在替换的过程中会使得数组不正确，通过记录preIndex找到正确值
  var reuseNodes = []; // 记录复用的 VNode
  var i = 0;
  var oldNodeFromMap;
  var last;
  for (; leftIdx < rightIdx; leftIdx++) {
    oldNodeFromMap = getOldNodeFromMap(leftChildrenMap, leftIdx, newChildren[leftIdx]);
    newNode = getNewNode(parentNode, newChildren[leftIdx], oldNodeFromMap);
    if (newNode !== null) {
      if (newNode.isCreated) {
        // 新VNode，直接打上标签新增，不参与到复用，旧的VNode会在后面打上delete标签
        FlagUtils.setAddition(newNode);
      } else {
        // 从Map删除，后面不会deleteVNode，就可以实现复用
        leftChildrenMap.delete(newNode.key || leftIdx);
        if (oldNodeFromMap !== null) {
          var eIndex = newNode.eIndex;
          eIndexes.push(eIndex);
          last = eIndexes[result[result.length - 1]];
          if (eIndex > last || last === undefined) {
            // 大的 eIndex直接放在最后
            preIndex[i] = result[result.length - 1];
            result.push(i);
          } else {
            var start = 0;
            var end = result.length - 1;
            var middle = void 0;
            // 二分法找到需要替换的值
            while (start < end) {
              middle = Math.floor((start + end) / 2);
              if (eIndexes[result[middle]] > eIndex) {
                end = middle;
              } else {
                start = middle + 1;
              }
            }
            if (eIndex < eIndexes[result[start]]) {
              preIndex[i] = result[start - 1];
              result[start] = i;
            }
          }
          i++;
          reuseNodes.push(newNode); // 记录所有复用的节点
        }
      }

      newNode.eIndex = leftIdx;
      appendNode(newNode);
    }
  }

  // 向前回溯找到正确的结果
  var length = result.length;
  var prev = result[length - 1];
  while (length-- > 0) {
    result[length] = prev;
    prev = preIndex[result[length]];
  }
  result.forEach(function (idx) {
    // 把需要复用的节点从 restNodes 中清理掉，因为不需要打 add 标记，直接复用 dom 节点
    reuseNodes[idx] = null;
  });
  reuseNodes.forEach(function (node) {
    if (node !== null) {
      // 没有被清理的节点打上 add 标记，通过dom的append操作实现位置移动
      FlagUtils.setAddition(node);
    }
  });
  leftChildrenMap.forEach(function (child) {
    deleteVNode(parentNode, child);
  });
  if (rightNewNode) {
    appendNode(rightNewNode);
    setVNodesCIndex(rightNewNode.next, rightNewNode.cIndex + 1);
  }
  return resultingFirstChild;
}

// 设置vNode中的cIndex属性，cIndex是节点在children中的位置
function setVNodesCIndex(startChild, startIdx) {
  var node = startChild;
  var idx = startIdx;
  while (node !== null) {
    node.cIndex = idx;
    markVNodePath(node);
    node = node.next;
    idx++;
  }
}

// 新节点是迭代器类型
function diffIteratorNodesHandler(parentNode, firstChild, newChildrenIterable) {
  var iteratorFn = getIteratorFn(newChildrenIterable);
  var iteratorObj = iteratorFn.call(newChildrenIterable);

  // 把iterator转测数组
  var childrenArray = [];
  var result = iteratorObj.next();
  while (!result.done) {
    childrenArray.push(result.value);
    result = iteratorObj.next();
  }
  return diffArrayNodesHandler(parentNode, firstChild, childrenArray);
}

// 新节点是字符串类型
function diffStringNodeHandler(parentNode, newChild, firstChildVNode, isComparing) {
  var newTextNode = null;

  // 第一个vNode是Text，则复用
  if (firstChildVNode !== null && firstChildVNode.tag === DomText) {
    newTextNode = updateVNode(firstChildVNode, String(newChild));
    deleteVNodes(parentNode, firstChildVNode.next);
    newTextNode.next = null;
  } else {
    newTextNode = createDomTextVNode(String(newChild));
    deleteVNodes(parentNode, firstChildVNode);
  }
  if (isComparing && newTextNode.isCreated) {
    FlagUtils.setAddition(newTextNode);
  }
  newTextNode.parent = parentNode;
  newTextNode.cIndex = 0;
  markVNodePath(newTextNode);
  return newTextNode;
}

// 新节点是对象类型
function diffObjectNodeHandler(parentNode, firstChild, newChild, firstChildVNode, isComparing) {
  var canReuseNode = null;

  // 通过key比对是否有可以reuse
  var newKey = newChild.key;
  var node = firstChild;
  while (node !== null) {
    if (node.key === newKey) {
      canReuseNode = node;
      break;
    } else {
      deleteVNode(parentNode, node);
      node = node.next;
    }
  }
  var resultNode = null;
  var startDelVNode = firstChildVNode;
  if (newChild.vtype === TYPE_COMMON_ELEMENT) {
    if (canReuseNode) {
      // 可以复用
      if (canReuseNode.tag === Fragment && newChild.type === TYPE_FRAGMENT) {
        resultNode = updateVNode(canReuseNode, newChild.props.children);
        startDelVNode = canReuseNode.next;
        resultNode.next = null;
      } else if (isSameType(canReuseNode, newChild)) {
        resultNode = updateVNode(canReuseNode, newChild.props);
        resultNode.ref = newChild.ref;
        resultNode.belongClassVNode = newChild.belongClassVNode;
        startDelVNode = resultNode.next;
        resultNode.next = null;
      }
    }
    if (resultNode === null) {
      // 新建
      if (newChild.type === TYPE_FRAGMENT) {
        resultNode = createFragmentVNode(newChild.key, newChild.props.children);
      } else {
        resultNode = createVNodeFromElement(newChild);
        resultNode.ref = newChild.ref;
        resultNode.belongClassVNode = newChild.belongClassVNode;
      }
    }
  } else if (newChild.vtype === TYPE_PORTAL) {
    if (canReuseNode) {
      // 可以复用
      if (canReuseNode.tag === DomPortal && canReuseNode.realNode === newChild.realNode) {
        resultNode = updateVNode(canReuseNode, newChild.children || []);
        startDelVNode = canReuseNode.next;
        resultNode.next = null;
      }
    }
    if (resultNode === null) {
      // 新建
      resultNode = createPortalVNode(newChild);
    }
  }
  if (resultNode) {
    if (isComparing && resultNode.isCreated) {
      FlagUtils.setAddition(resultNode);
    }
    resultNode.parent = parentNode;
    resultNode.cIndex = 0;
    markVNodePath(resultNode);
    if (startDelVNode) {
      deleteVNodes(parentNode, startDelVNode);
    }
    return resultNode;
  }
  return null;
}

// Diff算法的对外接口
function createChildrenByDiff(parentNode, firstChild, newChild, isComparing) {
  var isFragment = isNoKeyFragment(newChild);
  newChild = isFragment ? newChild.props.children : newChild;

  // 1. 没有新节点，直接把vNode标记为删除
  if (newChild == null) {
    if (isComparing) {
      deleteVNodes(parentNode, firstChild);
    }
    return null;
  }

  // 2. newChild是字串类型
  if (isTextType(newChild)) {
    return diffStringNodeHandler(parentNode, newChild, firstChild, isComparing);
  }

  // 3. newChild是数组类型
  if (Array.isArray(newChild)) {
    return diffArrayNodesHandler(parentNode, firstChild, newChild);
  }

  // 4. newChild是迭代器类型
  if (isIteratorType(newChild)) {
    return diffIteratorNodesHandler(parentNode, firstChild, newChild);
  }

  // 5. newChild是对象类型
  if (isObjectType(newChild)) {
    var newVNodes = diffObjectNodeHandler(parentNode, firstChild, newChild, firstChild, isComparing);
    if (newVNodes) {
      return newVNodes;
    }
  }

  // 6. 其它情况删除所有节点
  if (firstChild) {
    deleteVNodes(parentNode, firstChild);
  }
  return null;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 在useState, useReducer的时候，会触发state变化
var stateChange = false;
function bubbleRender$c() {}

// 判断children是否可以复用
function checkIfCanReuseChildren(processing) {
  return !processing.isCreated && processing.oldProps === processing.props && !processing.isDepContextChange;
}
function setStateChange(isUpdate) {
  stateChange = isUpdate;
}
function isStateChange() {
  return stateChange;
}
function captureFunctionComponent(processing, funcComp, nextProps) {
  // 函数组件内已完成异步动作
  if (processing.isSuspended) {
    // 由于首次被打断，应仍为首次渲染
    processing.isCreated = true;
    FlagUtils.markAddition(processing);
    processing.isSuspended = false;
  }
  resetDepContexts(processing);
  var isCanReuse = checkIfCanReuseChildren(processing);
  // 在执行exeFunctionHook前先设置stateChange为false
  setStateChange(false);
  var newElements = runFunctionWithHooks(processing.tag === ForwardRef ? funcComp.render : funcComp, nextProps, processing.tag === ForwardRef ? processing.ref : undefined, processing);
  callRenderEffects(processing);

  // 这里需要判断是否可以复用，因为函数组件比起其他组件，多了context、stateChange、或者store改变了 三个因素
  if (isCanReuse && !isStateChange() && !processing.isStoreChange) {
    FlagUtils.removeFlag(processing, Update);
    return onlyUpdateChildVNodes(processing);
  }
  processing.isStoreChange = false;
  processing.child = createChildrenByDiff(processing, processing.child, newElements, !processing.isCreated);
  return processing.child;
}
function captureRender$c(processing) {
  var Component = processing.type;
  var unresolvedProps = processing.props;
  var resolvedProps = processing.isLazyComponent ? mergeDefaultProps(Component, unresolvedProps) : unresolvedProps;
  return captureFunctionComponent(processing, Component, resolvedProps);
}

var FunctionComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$c,
  setStateChange: setStateChange,
  isStateChange: isStateChange,
  captureFunctionComponent: captureFunctionComponent,
  captureRender: captureRender$c
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 兼容IE浏览器没有Object.is
 */
function isSame$1(x, y) {
  if (!(typeof Object.is === 'function')) {
    if (x === y) {
      // +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // NaN == NaN
      return x !== x && y !== y;
    }
  } else {
    return Object.is(x, y);
  }
}
function isArrayEqual(nextParam, lastParam) {
  if (lastParam === null || lastParam.length !== nextParam.length) {
    return false;
  }
  for (var i = 0; i < lastParam.length; i++) {
    if (!isSame$1(nextParam[i], lastParam[i])) {
      return false;
    }
  }
  return true;
}
function shallowCompare(paramX, paramY) {
  if (isSame$1(paramX, paramY)) {
    return true;
  }

  // 对比对象
  if (typeof paramX === 'object' && typeof paramY === 'object' && paramX !== null && paramY !== null) {
    var keysX = Object.keys(paramX);
    var keysY = Object.keys(paramY);

    // key长度不相等时直接返回不相等
    if (keysX.length !== keysY.length) {
      return false;
    }
    return keysX.every(function (key, i) {
      return Object.prototype.hasOwnProperty.call(paramY, key) && isSame$1(paramX[key], paramY[keysX[i]]);
    });
  }
  return false;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function bubbleRender$b() {}
function captureMemoComponent(processing, shouldUpdate) {
  var Component = processing.type;
  // 合并 函数组件或类组件 的defaultProps
  var newProps = mergeDefaultProps(Component, processing.props);
  if (processing.isCreated) {
    var _newChild = null;
    var type = Component.type;
    if (type === TYPE_STRICT_MODE || type === TYPE_FRAGMENT || type === TYPE_PROFILER) {
      _newChild = createFragmentVNode(null, newProps.children);
    } else {
      _newChild = createUndeterminedVNode(type, null, newProps, processing.src);
    }
    _newChild.parent = processing;
    _newChild.ref = processing.ref;
    markVNodePath(_newChild);
    processing.child = _newChild;
    return _newChild;
  }
  var firstChild = processing.child; // Memo只有一个child
  if (!shouldUpdate) {
    var oldProps = firstChild.props;
    // 默认是浅对比
    var compare = Component.compare ? Component.compare : shallowCompare;
    if (compare(oldProps, newProps) && processing.oldRef === processing.ref) {
      return onlyUpdateChildVNodes(processing);
    }
  }
  var newChild = updateVNode(firstChild, newProps);
  newChild.parent = processing;
  newChild.cIndex = 0;
  markVNodePath(newChild);
  newChild.ref = processing.ref;
  processing.child = newChild;
  return newChild;
}
function captureRender$b(processing, shouldUpdate) {
  return captureMemoComponent(processing, shouldUpdate);
}

var MemoComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$b,
  captureMemoComponent: captureMemoComponent,
  captureRender: captureRender$b
});

var _LazyRendererMap;
function bubbleRender$a() {}
var LazyRendererMap = (_LazyRendererMap = {}, _defineProperty(_LazyRendererMap, FunctionComponent, captureFunctionComponent), _defineProperty(_LazyRendererMap, ClassComponent, captureRender$9), _defineProperty(_LazyRendererMap, ForwardRef, captureFunctionComponent), _defineProperty(_LazyRendererMap, MemoComponent, captureMemoComponent), _LazyRendererMap);
function mergeDefaultProps(Component, props) {
  if (Component && Component.defaultProps) {
    var clonedProps = _extends({}, props);
    var defaultProps = Component.defaultProps;
    Object.keys(defaultProps).forEach(function (key) {
      if (clonedProps[key] === undefined) {
        clonedProps[key] = defaultProps[key];
      }
    });
    return clonedProps;
  }
  return props;
}
function captureLazyComponent(processing, lazyComponent, shouldUpdate) {
  if (!processing.isCreated) {
    // 每次加载lazy都当作mount来处理
    processing.isCreated = true;
    FlagUtils.markAddition(processing);
  }
  var Component = lazyComponent._load(lazyComponent._content);

  // ======================loaded===============================
  // 加载得到的Component存在type中
  processing.type = Component;
  var lazyVNodeTag = getLazyVNodeTag(Component);
  processing.tag = lazyVNodeTag;
  var lazyVNodeProps = mergeDefaultProps(Component, processing.props);
  var lazyRender = LazyRendererMap[lazyVNodeTag];
  if (lazyRender) {
    if (lazyVNodeTag === MemoComponent) {
      // Memo要特殊处理
      processing.effectList = null;
      var memoVNodeProps = mergeDefaultProps(Component.type, lazyVNodeProps); // 需要整合defaultProps
      return lazyRender(processing, Component, memoVNodeProps, shouldUpdate);
    } else {
      return lazyRender(processing, Component, lazyVNodeProps, false);
    }
  } else {
    // lazy加载的组件类型未受支持
    throwIfTrue(true, 'Element type is invalid. Received a promise that resolves to: %s. ' + 'Lazy element type must resolve to a class or function.%s', Component, '');
    return null;
  }
}
function captureRender$a(processing, shouldUpdate) {
  return captureLazyComponent(processing, processing.type, shouldUpdate);
}

var LazyComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$a,
  mergeDefaultProps: mergeDefaultProps,
  captureRender: captureRender$a
});

function callDerivedStateFromProps(processing, getDerivedStateFromProps, nextProps) {
  if (getDerivedStateFromProps) {
    var oldState = processing.state;

    // 调用class组件的getDerivedStateFromProps函数
    var newState = getDerivedStateFromProps(nextProps, oldState);

    // 组件未返回state,需要返回旧的preState
    processing.state = newState === null || newState === undefined ? oldState : _extends({}, oldState, newState);
  }
}
function changeStateContent(type, content, callback) {
  // @ts-ignore
  var vNode = this._vNode;
  var update = newUpdate();
  update.type = type;
  if (type === UpdateState.Update || type === UpdateState.Override) {
    update.content = content;
  }
  if (callback) {
    update.callback = callback;
  }
  pushUpdate(vNode, update);
  launchUpdateFromVNode(vNode);
}
function callShouldComponentUpdate(processing, oldProps, newProps, newState, newContext) {
  var inst = processing.realNode;
  if (inst.shouldComponentUpdate) {
    return inst.shouldComponentUpdate(newProps, newState, newContext);
  }
  if (inst instanceof PureComponent) {
    return !shallowCompare(oldProps, newProps) || !shallowCompare(inst.state, newState);
  }
  return true;
}
function setStateAndForceUpdateImpl(inst) {
  inst.setState = changeStateContent.bind(inst, UpdateState.Update);
  inst.forceUpdate = changeStateContent.bind(inst, UpdateState.ForceUpdate, null);
}
function callConstructor(processing, ctor, props) {
  var context = getCurrentContext(ctor, processing);
  var inst = new ctor(props, context);
  if (inst.state !== null && inst.state !== undefined) {
    processing.state = inst.state;
  }
  setStateAndForceUpdateImpl(inst);
  // 双向绑定processing和inst
  processing.realNode = inst;
  inst._vNode = processing;
  return inst;
}
function callComponentWillMount(processing, inst, newProps) {
  var oldState = inst.state;
  if (inst.componentWillMount) {
    inst.componentWillMount();
  }
  if (inst.UNSAFE_componentWillMount) {
    inst.UNSAFE_componentWillMount();
  }
  if (oldState !== inst.state) {
    changeStateContent.call(inst, UpdateState.Override, inst.state, null);
  }

  // 处理componentWillMount中可能存在的state更新行为
  processUpdates(processing, inst, newProps);
  inst.state = processing.state;
}
function callComponentWillUpdate(inst, newProps, newState, nextContext) {
  if (inst.componentWillUpdate) {
    inst.componentWillUpdate(newProps, newState, nextContext);
  }
  if (inst.UNSAFE_componentWillUpdate) {
    inst.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
  }
}
function callComponentWillReceiveProps(inst, newProps, newContext) {
  if (inst.componentWillReceiveProps) {
    var oldState = inst.state;
    inst.componentWillReceiveProps(newProps, newContext);
    if (inst.state !== oldState) {
      changeStateContent.call(inst, UpdateState.Override, inst.state, null);
    }
  }
  if (inst.UNSAFE_componentWillReceiveProps) {
    var _oldState = inst.state;
    inst.UNSAFE_componentWillReceiveProps(newProps, newContext);
    if (inst.state !== _oldState) {
      changeStateContent.call(inst, UpdateState.Override, inst.state, null);
    }
  }
}
function markComponentDidMount(processing) {
  var inst = processing.realNode;
  if (inst.componentDidMount) {
    FlagUtils.markUpdate(processing);
  }
}
function markGetSnapshotBeforeUpdate(processing) {
  var inst = processing.realNode;
  if (inst.getSnapshotBeforeUpdate) {
    FlagUtils.markSnapshot(processing);
  }
}
function markComponentDidUpdate(processing) {
  var inst = processing.realNode;
  if (inst.componentDidUpdate) {
    FlagUtils.markUpdate(processing);
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var emptyContextObj = {};
// 获取当前节点的context
function getCurrentContext(clazz, processing) {
  var context = clazz.contextType;
  return typeof context === 'object' && context !== null ? getNewContext(processing, context) : emptyContextObj;
}

// 挂载实例
function mountInstance(ctor, processing, nextProps) {
  if (!processing.isCreated) {
    processing.isCreated = true;
    FlagUtils.markAddition(processing);
  }

  // 构造实例
  var inst = callConstructor(processing, ctor, nextProps);
  inst.props = nextProps;
  inst.state = processing.state;
  inst.context = getCurrentContext(ctor, processing);
  inst.refs = {};
  processUpdates(processing, inst, nextProps);
  inst.state = processing.state;

  // 在调用类组建的渲染方法之前调用 并且在初始挂载及后续更新时都会被调用
  callDerivedStateFromProps(processing, ctor.getDerivedStateFromProps, nextProps);
  callComponentWillMount(processing, inst, nextProps);
  markComponentDidMount(processing);
}

// 构建子节点
function createChildren(clazz, processing) {
  processing.isStoreChange = false;
  markRef(processing);
  setProcessingClassVNode(processing);
  processing.state = processing.realNode.state;
  var inst = processing.realNode;
  var isCatchError = (processing.flags & DidCapture) === DidCapture;

  // 按照已有规格，如果捕获了错误却没有定义getDerivedStateFromError函数，返回的child为null
  var newElements = isCatchError && typeof clazz.getDerivedStateFromError !== 'function' ? null : inst.render();
  processing.child = createChildrenByDiff(processing, processing.child, newElements, !processing.isCreated);
  return processing.child;
}

// 根据isUpdateComponent，执行不同的生命周期
function callUpdateLifeCycle(processing, nextProps, clazz) {
  var inst = processing.realNode;
  var newContext = getCurrentContext(clazz, processing);
  if (processing.isCreated) {
    callComponentWillMount(processing, inst);
  } else {
    callComponentWillUpdate(inst, nextProps, processing.state, newContext);
  }
}
function markLifeCycle(processing, nextProps, shouldUpdate) {
  if (processing.isCreated) {
    markComponentDidMount(processing);
  } else if (processing.state !== processing.oldState || shouldUpdate) {
    markComponentDidUpdate(processing);
    markGetSnapshotBeforeUpdate(processing);
  }
}

// 用于类组件
function captureRender$9(processing) {
  var ctor = processing.type;
  var nextProps = processing.props;
  if (processing.isLazyComponent) {
    nextProps = mergeDefaultProps(ctor, nextProps);
  }
  resetDepContexts(processing);

  // suspense打断后，再次render只需初次渲染
  if (processing.isSuspended) {
    mountInstance(ctor, processing, nextProps);
    processing.isSuspended = false;
    return createChildren(ctor, processing);
  }

  // 通过 shouldUpdate 判断是否要复用 children，该值和props,state,context的变化，shouldComponentUpdate,forceUpdate api的调用结果有关
  var shouldUpdate;
  var inst = processing.realNode;
  if (inst === null) {
    // 挂载新组件，一定会更新
    mountInstance(ctor, processing, nextProps);
    shouldUpdate = true;
  } else {
    // 更新
    var newContext = getCurrentContext(ctor, processing);

    // 子节点抛出异常时，如果本class是个捕获异常的处理节点，这时候oldProps是null，所以需要使用props
    var oldProps = (processing.flags & DidCapture) === DidCapture ? processing.props : processing.oldProps;
    if (oldProps !== processing.props || inst.context !== newContext) {
      // 在已挂载的组件接收新的 props 之前被调用
      callComponentWillReceiveProps(inst, nextProps, newContext);
    }
    processUpdates(processing, inst, nextProps);

    // 如果 props, state, context 都没有变化且 isForceUpdate 为 false则不需要更新
    shouldUpdate = oldProps !== processing.props || inst.state !== processing.state || processing.isForceUpdate;
    if (shouldUpdate) {
      // derivedStateFromProps会修改nextState，因此需要调用
      callDerivedStateFromProps(processing, ctor.getDerivedStateFromProps, nextProps);
      if (!processing.isForceUpdate) {
        // 业务可以通过 shouldComponentUpdate 函数进行优化阻止更新
        shouldUpdate = callShouldComponentUpdate(processing, oldProps, nextProps, processing.state, newContext);
      }
      if (shouldUpdate) {
        callUpdateLifeCycle(processing, nextProps, ctor);
      }
      inst.state = processing.state;
      inst.context = newContext;
    }
    markLifeCycle(processing, nextProps, shouldUpdate);
    // 不管有没有更新，props都必须更新
    inst.props = nextProps;
  }
  // 如果捕获了 error，必须更新
  var isCatchError = (processing.flags & DidCapture) === DidCapture;
  shouldUpdate = isCatchError || shouldUpdate || processing.isStoreChange;

  // 更新ref
  markRef(processing);

  // 不复用
  if (shouldUpdate) {
    return createChildren(ctor, processing);
  } else {
    return onlyUpdateChildVNodes(processing);
  }
}
function bubbleRender$9() {}

var ClassComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getCurrentContext: getCurrentContext,
  captureRender: captureRender$9,
  bubbleRender: bubbleRender$9
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function captureContextConsumer(processing) {
  var context = processing.type;
  var props = processing.props;
  var renderFunc = props.children;
  resetDepContexts(processing);
  var contextVal = getNewContext(processing, context);
  var newChildren = renderFunc(contextVal);
  processing.child = createChildrenByDiff(processing, processing.child, newChildren, !processing.isCreated);
  return processing.child;
}
function captureRender$8(processing) {
  return captureContextConsumer(processing);
}
function bubbleRender$8() {}

var ContextConsumerRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  captureRender: captureRender$8,
  bubbleRender: bubbleRender$8
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function updateShouldUpdateOfTree(vNode) {
  vNode.shouldUpdate = true;

  // 一直向上遍历，修改childShouldUpdate
  var node = vNode;
  var parent = vNode.parent;
  while (parent !== null) {
    parent.childShouldUpdate = true;
    node = parent;
    parent = parent.parent;
  }
  if (node.tag === TreeRoot) {
    node.shouldUpdate = true;
    // 返回根节点
    return node;
  }
  return null;
}

// 设置节点的childShouldUpdate
function updateChildShouldUpdate(vNode) {
  var child = vNode.child;
  while (child !== null) {
    if (child.shouldUpdate || child.childShouldUpdate) {
      vNode.childShouldUpdate = true;
      return;
    }
    child = child.next;
  }
  vNode.childShouldUpdate = false;
}

// 更新从当前节点到根节点的childShouldUpdate为true
function setParentsChildShouldUpdate(parent) {
  var node = parent;
  while (node !== null) {
    if (node.childShouldUpdate) {
      break;
    }
    node.childShouldUpdate = true;
    node = node.parent;
  }
}

// 设置节点的所有父节点的childShouldUpdate
function updateParentsChildShouldUpdate(vNode) {
  var node = vNode.parent;
  var isShouldUpdate = vNode.shouldUpdate || vNode.childShouldUpdate;
  if (isShouldUpdate) {
    // 开始节点是shouldUpdate或childShouldUpdate
    // 更新从当前节点到根节点的childShouldUpdate为true
    setParentsChildShouldUpdate(node);
  } else {
    while (node !== null) {
      updateChildShouldUpdate(node);
      node = node.parent;
    }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 从依赖中找到匹配context的VNode
function matchDependencies(depContexts, context, vNode) {
  for (var i = 0; i < depContexts.length; i++) {
    var contextItem = depContexts[i];
    if (contextItem === context) {
      // 匹配到了更新的context，需要创建update。
      if (vNode.tag === ClassComponent) {
        pushForceUpdate(vNode);
      }
      vNode.shouldUpdate = true;

      // 找到需要更新的节点，所以祖先节点都需要改为shouldUpdate为true
      setParentsChildShouldUpdate(vNode.parent);
      vNode.isDepContextChange = true;
      // 由于我们已经找到匹配项，我们可以停止遍历依赖项列表。
      return true;
    }
  }
  return false;
}

// 从当前子节点开始向下遍历，找到消费此context的组件，并更新
function handleContextChange(processing, context) {
  var vNode = processing.child;
  if (vNode === null) {
    return;
  }
  var isMatch = false;

  // 从vNode开始遍历
  travelVNodeTree(vNode, function (node) {
    var depContexts = node.depContexts;
    if (depContexts && depContexts.length) {
      var _matchDependencies;
      isMatch = (_matchDependencies = matchDependencies(depContexts, context, node)) !== null && _matchDependencies !== void 0 ? _matchDependencies : isMatch;
    }
  }, function (node) {
    return (
      // 如果这是匹配的provider，则不要更深入地扫描
      node.tag === ContextProvider && node.type === processing.type
    );
  }, processing, null);

  // 找到了依赖context的子节点，触发一次更新
  if (isMatch) {
    launchUpdateFromVNode(processing);
  }
}
function captureContextProvider(processing) {
  var providerType = processing.type;
  var contextType = providerType._context;
  var newProps = processing.props;
  var oldProps = !processing.isCreated ? processing.oldProps : null;

  // 获取provider设置的context，即provider组件设置的value
  var newCtx = newProps.value;

  // 更新processing的context值为newProps.value
  setContext(processing, newCtx);
  if (oldProps !== null) {
    var oldCtx = oldProps.value;
    var isSameContext = isSame$1(oldCtx, newCtx);
    if (isSameContext) {
      // context没有改变，复用
      if (oldProps.children === newProps.children) {
        return onlyUpdateChildVNodes(processing);
      }
    } else {
      // context更改，更新所有依赖的组件
      handleContextChange(processing, contextType);
    }
  }
  var newElements = newProps.children;
  processing.child = createChildrenByDiff(processing, processing.child, newElements, !processing.isCreated);
  return processing.child;
}
function captureRender$7(processing) {
  return captureContextProvider(processing);
}
function bubbleRender$7(processing) {
  resetContext(processing);
}

var ContextProviderRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  captureRender: captureRender$7,
  bubbleRender: bubbleRender$7
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function captureRender$6(processing) {
  return captureRender$c(processing);
}
function bubbleRender$6() {}

var ForwardRefRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  captureRender: captureRender$6,
  bubbleRender: bubbleRender$6
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function bubbleRender$5() {}
function captureFragment(processing) {
  var newElement = processing.props;
  processing.child = createChildrenByDiff(processing, processing.child, newElement, !processing.isCreated);
  return processing.child;
}
function captureRender$5(processing) {
  return captureFragment(processing);
}

var FragmentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$5,
  captureRender: captureRender$5
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function updateDom(processing, type, newProps) {
  // 如果oldProps !== newProps，意味着存在更新，并且需要处理其相关的副作用
  var oldProps = processing.oldProps;
  if (oldProps === newProps) {
    // 如果props没有发生变化，即使它的children发生了变化，我们也不会改变它
    return;
  }
  var dom = processing.realNode;
  var changeList = getPropChangeList(dom, type, oldProps, newProps);

  // 输入类型的直接标记更新
  if (type === 'input' || type === 'textarea' || type === 'select' || type === 'option') {
    FlagUtils.markUpdate(processing);
    processing.changeList = changeList;
  } else {
    // 其它的类型，数据有变化才标记更新
    if (Object.keys(changeList).length) {
      processing.changeList = changeList;
      FlagUtils.markUpdate(processing);
    }
  }
}
function bubbleRender$4(processing) {
  resetNamespaceCtx(processing);
  var type = processing.type;
  var newProps = processing.props;
  if (!processing.isCreated && processing.realNode != null) {
    // 更新dom属性
    updateDom(processing, type, newProps);
    if (processing.oldRef !== processing.ref) {
      FlagUtils.markRef(processing);
    }
  } else {
    var parentNamespace = getNamespaceCtx();

    // 创建dom
    var dom = newDom(type, newProps, parentNamespace, processing);

    // 把dom类型的子节点append到parent dom中
    var vNode = processing.child;
    if (vNode !== null) {
      // 向下递归它的子节点，查找所有终端节点。
      travelVNodeTree(vNode, function (node) {
        if (node.tag === DomComponent || node.tag === DomText) {
          appendChildElement(dom, node.realNode);
        }
      }, function (node) {
        return (
          // 已经append到父节点，或者是DomPortal都不需要处理child了
          node.tag === DomComponent || node.tag === DomText || node.tag === DomPortal
        );
      }, processing, null);
    }
    processing.realNode = dom;
    if (initDomProps(dom, type, newProps)) {
      FlagUtils.markUpdate(processing);
    }

    // 处理ref导致的更新
    if (processing.ref !== null) {
      FlagUtils.markRef(processing);
    }
  }
}
function captureRender$4(processing) {
  setNamespaceCtx(processing);
  var type = processing.type;
  var newProps = processing.props;
  var oldProps = !processing.isCreated ? processing.oldProps : null;
  var nextChildren = newProps.children;
  var isDirectTextChild = isTextChild(type, newProps);
  if (isDirectTextChild) {
    // 如果为文本节点，则认为没有子节点
    nextChildren = null;
  } else if (oldProps !== null && isTextChild(type, oldProps)) {
    // 将纯文本的子节点改为vNode节点
    FlagUtils.markContentReset(processing);
  }
  markRef(processing);
  processing.child = createChildrenByDiff(processing, processing.child, nextChildren, !processing.isCreated);
  return processing.child;
}

var DomComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$4,
  captureRender: captureRender$4
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function bubbleRender$3(processing) {
  resetNamespaceCtx(processing);
  popCurrentRoot();
}
function capturePortalComponent(processing) {
  setNamespaceCtx(processing, processing.realNode);
  pushCurrentRoot(processing);
  var newElements = processing.props;
  if (processing.isCreated) {
    processing.child = createChildrenByDiff(processing, null, newElements, true);
  } else {
    processing.child = createChildrenByDiff(processing, processing.child, newElements, !processing.isCreated);
  }
  return processing.child;
}
function captureRender$3(processing) {
  return capturePortalComponent(processing);
}

var DomPortalRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$3,
  captureRender: captureRender$3
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function bubbleRender$2(processing) {
  resetNamespaceCtx(processing);
}
function updateTreeRoot(processing) {
  setNamespaceCtx(processing, processing.realNode);
  var updates = processing.updates;
  throwIfTrue(processing.isCreated || updates === null, 'If the root does not have an updates, we should have already ' + 'bailed out. This error is likely caused by a bug. Please ' + 'file an issue.');
  var newProps = processing.props;
  var oldState = processing.state;
  var oldElement = oldState !== null ? oldState.element : null;
  processUpdates(processing, null, newProps);
  var newState = processing.state;
  // 为了保持对Dev Tools的兼容，这里还是使用element
  var newElement = newState.element;
  if (newElement === oldElement) {
    return onlyUpdateChildVNodes(processing);
  }
  processing.child = createChildrenByDiff(processing, processing.child, newElement, !processing.isCreated);
  return processing.child;
}
function captureRender$2(processing) {
  return updateTreeRoot(processing);
}

var TreeRootRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bubbleRender: bubbleRender$2,
  captureRender: captureRender$2
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function captureRender$1() {
  return null;
}
function bubbleRender$1(processing) {
  var newText = processing.props;
  if (!processing.isCreated && processing.realNode != null) {
    // 更新
    var oldText = processing.oldProps;
    // 如果文本不同，将其标记为更新
    if (oldText !== newText) {
      FlagUtils.markUpdate(processing);
    }
  } else {
    // 初始化
    if (typeof newText !== 'string') {
      // 如果存在bug，可能出现这种情况
      throwIfTrue(processing.realNode === null, 'We must have new text for new mounted node. This error is likely ' + 'caused by a bug in Horizon. Please file an issue.');
    }
    // 获得对应节点
    processing.realNode = newTextDom(newText, processing);
  }
}

var DomTextRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  captureRender: captureRender$1,
  bubbleRender: bubbleRender$1
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var SuspenseChildStatus = /*#__PURE__*/function (SuspenseChildStatus) {
  SuspenseChildStatus["Init"] = "";
  SuspenseChildStatus["ShowChild"] = "showChild";
  SuspenseChildStatus["ShowFallback"] = "showFallback";
  return SuspenseChildStatus;
}({});

// 创建fallback子节点
function createFallback(processing, fallbackChildren) {
  var childFragment = processing.child;
  var fallbackFragment;
  childFragment.childShouldUpdate = false;
  if (!processing.isCreated) {
    var oldFallbackFragment = processing.oldChild ? processing.oldChild.next : null;
    if (oldFallbackFragment !== null) {
      fallbackFragment = updateVNode(oldFallbackFragment, fallbackChildren);
    } else {
      fallbackFragment = createFragmentVNode(null, fallbackChildren);
      FlagUtils.markAddition(fallbackFragment);
    }
  } else {
    // 创建
    fallbackFragment = createFragmentVNode(null, fallbackChildren);
  }
  processing.child = childFragment;
  childFragment.next = fallbackFragment;
  childFragment.parent = processing;
  fallbackFragment.parent = processing;
  fallbackFragment.eIndex = 1;
  fallbackFragment.cIndex = 1;
  markVNodePath(fallbackFragment);
  processing.suspenseState.childStatus = SuspenseChildStatus.ShowFallback;
  return fallbackFragment;
}

// 创建子节点
function createSuspenseChildren(processing, newChildren) {
  var childFragment;
  if (!processing.isCreated) {
    var oldChildFragment = processing.child;
    var oldFallbackFragment = oldChildFragment.next;
    childFragment = updateVNode(oldChildFragment);
    childFragment.next = null;
    // 将Suspense新的子参数传给子Fragment
    childFragment.props = processing.props.children;
    childFragment.shouldUpdate = true;

    // 删除fallback
    if (oldFallbackFragment !== null) {
      FlagUtils.setDeletion(oldFallbackFragment);
      processing.dirtyNodes = [oldFallbackFragment];
    }
    // SuspenseComponent 中使用
    processing.suspenseState.childStatus = SuspenseChildStatus.ShowChild;
  } else {
    childFragment = createFragmentVNode(null, newChildren);
  }
  childFragment.parent = processing;
  childFragment.cIndex = 0;
  markVNodePath(childFragment);
  processing.child = childFragment;
  processing.suspenseState.promiseResolved = false;
  return processing.child;
}
function captureSuspenseComponent(processing) {
  var nextProps = processing.props;

  // suspense被捕获后需要展示fallback
  var showFallback = processing.suspenseState.didCapture;
  if (showFallback) {
    processing.suspenseState.didCapture = false;
    var nextFallbackChildren = nextProps.fallback;
    return createFallback(processing, nextFallbackChildren);
  } else {
    var newChildren = nextProps.children;
    return createSuspenseChildren(processing, newChildren);
  }
}
function updateFallback(processing) {
  var childFragment = processing.child;
  if (childFragment !== null && childFragment !== void 0 && childFragment.childShouldUpdate) {
    if (processing.suspenseState.promiseResolved) {
      // promise已完成，展示promise返回的新节点
      return captureSuspenseComponent(processing);
    } else {
      // promise未完成，继续显示fallback，不需要继续刷新子节点
      var fallbackFragment = processing.child.next;
      childFragment.childShouldUpdate = false;
      fallbackFragment.childShouldUpdate = false;
      return null;
    }
  } else {
    var children = onlyUpdateChildVNodes(processing);
    if (children !== null) {
      // child不需要更新，跳过child处理fallback
      return children[1];
    } else {
      return null;
    }
  }
}
function captureRender(processing, shouldUpdate) {
  if (!processing.isCreated && processing.oldProps === processing.props && !shouldUpdate) {
    if (processing.suspenseState.childStatus === SuspenseChildStatus.ShowFallback) {
      // 当显示fallback时，suspense的子组件要更新
      return updateFallback(processing);
    }
    return onlyUpdateChildVNodes(processing);
  }
  return captureSuspenseComponent(processing);
}
function bubbleRender(processing) {
  var _processing$suspenseS = processing.suspenseState,
    childStatus = _processing$suspenseS.childStatus,
    oldChildStatus = _processing$suspenseS.oldChildStatus;
  if (childStatus === SuspenseChildStatus.ShowFallback || !processing.isCreated && oldChildStatus === SuspenseChildStatus.ShowFallback) {
    FlagUtils.markUpdate(processing);
  }
  return null;
}
function canCapturePromise(vNode) {
  return (vNode === null || vNode === void 0 ? void 0 : vNode.suspenseState.childStatus) !== SuspenseChildStatus.ShowFallback && (vNode === null || vNode === void 0 ? void 0 : vNode.props.fallback) !== undefined;
}

// 处理Suspense子组件抛出的promise
function handleSuspenseChildThrowError(parent, processing, promise) {
  var vNode = parent;

  // 向上找到最近的不在fallback状态的Suspense，并触发重新渲染
  do {
    if (vNode.tag === SuspenseComponent && canCapturePromise(vNode)) {
      if (vNode.suspenseState.promiseSet === null) {
        vNode.suspenseState.promiseSet = new Set();
      }
      vNode.suspenseState.promiseSet.add(promise);

      // 移除生命周期flag 和 中断flag
      FlagUtils.removeLifecycleEffectFlags(processing);
      FlagUtils.removeFlag(processing, Interrupted);
      if (processing.tag === ClassComponent) {
        if (processing.isCreated) {
          // 渲染类组件场景，要标志未完成（否则会触发componentWillUnmount）
          processing.isSuspended = true;
        } else {
          // 类组件更新，标记强制更新，否则被memo等优化跳过
          pushForceUpdate(processing);
          launchUpdateFromVNode(processing);
        }
      }
      if (processing.tag === FunctionComponent || processing.tag === ForwardRef) {
        processing.isSuspended = true;
      }
      // 应该抛出promise未完成更新，标志待更新
      processing.shouldUpdate = true;
      vNode.suspenseState.didCapture = true;
      launchUpdateFromVNode(vNode);
      return true;
    }
    vNode = vNode.parent;
  } while (vNode !== null);
  return false;
}
var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
function resolvePromise(suspenseVNode, promise) {
  var promiseCache = suspenseVNode.realNode;
  if (promiseCache !== null) {
    promiseCache.delete(promise);
  }
  suspenseVNode.suspenseState.promiseResolved = true;
  var root = updateShouldUpdateOfTree(suspenseVNode);
  if (root !== null) {
    tryRenderFromRoot(root);
  }
}

// 对于每个promise，添加一个侦听器，以便当它resolve时，重新渲染
function listenToPromise(suspenseVNode) {
  var promises = suspenseVNode.suspenseState.promiseSet;
  if (promises !== null) {
    suspenseVNode.suspenseState.promiseSet = null;

    // 记录已经监听的 promise
    var promiseCache = suspenseVNode.realNode;
    if (promiseCache === null) {
      promiseCache = new PossiblyWeakSet();
      suspenseVNode.realNode = new PossiblyWeakSet();
    }
    promises.forEach(function (promise) {
      var resole = resolvePromise.bind(null, suspenseVNode, promise);
      if (!promiseCache.has(promise)) {
        promiseCache.add(promise);
        // 监听promise
        promise.then(resole, resole);
      }
    });
  }
}

var SuspenseComponentRender = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SuspenseChildStatus: SuspenseChildStatus,
  captureSuspenseComponent: captureSuspenseComponent,
  captureRender: captureRender,
  bubbleRender: bubbleRender,
  handleSuspenseChildThrowError: handleSuspenseChildThrowError,
  listenToPromise: listenToPromise
});

var _ClassComponent$Conte;
var componentRenders = (_ClassComponent$Conte = {}, _defineProperty(_ClassComponent$Conte, ClassComponent, ClassComponentRender), _defineProperty(_ClassComponent$Conte, ContextConsumer, ContextConsumerRender), _defineProperty(_ClassComponent$Conte, ContextProvider, ContextProviderRender), _defineProperty(_ClassComponent$Conte, ForwardRef, ForwardRefRender), _defineProperty(_ClassComponent$Conte, Fragment, FragmentRender), _defineProperty(_ClassComponent$Conte, FunctionComponent, FunctionComponentRender), _defineProperty(_ClassComponent$Conte, DomComponent, DomComponentRender), _defineProperty(_ClassComponent$Conte, DomPortal, DomPortalRender), _defineProperty(_ClassComponent$Conte, TreeRoot, TreeRootRender), _defineProperty(_ClassComponent$Conte, DomText, DomTextRender), _defineProperty(_ClassComponent$Conte, LazyComponent, LazyComponentRender), _defineProperty(_ClassComponent$Conte, MemoComponent, MemoComponentRender), _defineProperty(_ClassComponent$Conte, SuspenseComponent, SuspenseComponentRender), _ClassComponent$Conte);

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useRefImpl(value) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  var hook;
  if (stage === HookStage.Init) {
    hook = createHook();
    hook.state = {
      current: value
    };
  } else if (stage === HookStage.Update) {
    hook = getCurrentHook();
  }
  return hook.state;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useEffectImpl(effectFunc, deps) {
  // 异步触发的effect
  useEffect$1(effectFunc, deps, EffectConstant.Effect);
}
function useLayoutEffectImpl(effectFunc, deps) {
  // 同步触发的effect
  useEffect$1(effectFunc, deps, EffectConstant.LayoutEffect);
}
function useRenderEffectImpl(effectFunc, deps) {
  useEffect$1(effectFunc, deps, EffectConstant.RenderEffect);
}
function useEffect$1(effectFunc, deps, effectType) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  if (stage === HookStage.Init) {
    useEffectForInit(effectFunc, deps, effectType);
  } else if (stage === HookStage.Update) {
    useEffectForUpdate(effectFunc, deps, effectType);
  }
}
function useEffectForInit(effectFunc, deps, effectType) {
  FlagUtils.markUpdate(getProcessingVNode());
  var hook = createHook();
  var nextDeps = deps !== undefined ? deps : null;
  // 初始阶段，设置DepsChange标记位; 构造EffectList数组，并赋值给state
  hook.state = createEffect(effectFunc, undefined, nextDeps, EffectConstant.DepsChange | effectType);
}
function useEffectForUpdate(effectFunc, deps, effectType) {
  var hook = getCurrentHook();
  var nextDeps = deps !== undefined ? deps : null;
  var removeFunc;
  if (getLastTimeHook() !== null) {
    var effect = getLastTimeHook().state;
    // removeEffect是通过执行effect返回的，所以需要在上一次hook中获取
    removeFunc = effect.removeEffect;
    var lastDeps = effect.dependencies;

    // 判断dependencies是否相同，同相同不需要设置DepsChange标记位
    if (nextDeps !== null && isArrayEqual(nextDeps, lastDeps)) {
      hook.state = createEffect(effectFunc, removeFunc, nextDeps, effectType);
      return;
    }
  }
  FlagUtils.markUpdate(getProcessingVNode());
  // 设置DepsChange标记位，构造Effect，并赋值给state
  hook.state = createEffect(effectFunc, removeFunc, nextDeps, EffectConstant.DepsChange | effectType);
}
function createEffect(effectFunc, removeFunc, deps, effectConstant) {
  var effect = {
    effect: effectFunc,
    removeEffect: removeFunc,
    dependencies: deps,
    effectConstant: effectConstant
  };
  getProcessingVNode().effectList.push(effect);
  return effect;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useCallbackImpl(func, dependencies) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  var hook;
  var deps = dependencies !== undefined ? dependencies : null;
  if (stage === HookStage.Init) {
    hook = createHook();
    hook.state = {
      func: func,
      dependencies: deps
    };
  } else if (stage === HookStage.Update) {
    hook = getCurrentHook();
    var lastState = hook.state;
    // 判断dependencies是否相同，不同就不更新state
    if (lastState !== null && deps !== null && isArrayEqual(deps, lastState.dependencies)) {
      return lastState.func;
    }
    hook.state = {
      func: func,
      dependencies: deps
    };
  }
  return func;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useMemoImpl(fun, deps) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  var hook;
  var result;
  var nextDeps = deps === undefined ? null : deps;
  if (stage === HookStage.Init) {
    hook = createHook();
    result = fun();
  } else if (stage === HookStage.Update) {
    hook = getCurrentHook();
    var lastState = hook.state;
    // dependencies相同，不更新state
    if (lastState !== null && nextDeps !== null && isArrayEqual(nextDeps, lastState.dependencies)) {
      return lastState.result;
    }
    result = fun();
  }
  hook.state = {
    result: result,
    dependencies: nextDeps
  };
  return hook.state.result;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useImperativeHandleImpl(ref, func, dependencies) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  var params = isNotNull(dependencies) ? dependencies.concat([ref]) : null;
  useLayoutEffectImpl(effectFunc.bind(null, func, ref), params);
}
function isNotNull(object) {
  return object !== null && object !== undefined;
}
function effectFunc(func, ref) {
  if (typeof ref === 'function') {
    var value = func();
    ref(value);
    return function () {
      ref(null);
    };
  }
  if (isNotNull(ref)) {
    ref.current = func();
    return function () {
      ref.current = null;
    };
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useReducerImpl(reducer, initArg, init, isUseState) {
  var stage = getHookStage();
  if (stage === null) {
    throwNotInFuncError();
  }
  if (stage === HookStage.Init) {
    return useReducerForInit(reducer, initArg, init, isUseState);
  } else if (stage === HookStage.Update) {
    // 获取当前的hook
    var currentHook = getCurrentHook();
    // 获取currentHook的更新数组
    var currentHookUpdates = currentHook.state.updates;
    return updateReducerHookState(currentHookUpdates, currentHook, reducer);
  }
}

// 构造新的Update数组
function insertUpdate(action, hook) {
  var newUpdate = {
    action: action,
    state: null,
    didCalculated: false
  };
  var updates = hook.state.updates;
  // 更新updates数组，newUpdate添加至数组尾部
  if (updates === null) {
    updates = [newUpdate];
    hook.state.updates = updates;
  } else {
    updates.push(newUpdate);
  }
  return newUpdate;
}

// setState, setReducer触发函数
function TriggerAction(vNode, hook, isUseState, action) {
  var newUpdate = insertUpdate(action, hook);

  // 判断是否需要刷新
  if (!vNode.shouldUpdate && isUseState) {
    var _ref = hook.state,
      stateValue = _ref.stateValue,
      reducer = _ref.reducer;
    if (reducer === null) {
      return;
    }
    // 在进入render阶段前reducer没有变化，可以复用state值，提升性能
    newUpdate.state = reducer(stateValue, action);

    // 标记为已经计算过，不需要重新计算了
    newUpdate.didCalculated = true;
    if (isSame$1(newUpdate.state, stateValue)) {
      return;
    }
  }

  // 执行vNode节点渲染
  launchUpdateFromVNode(vNode);
}
function useReducerForInit(reducer, initArg, init, isUseState) {
  // 计算初始stateValue
  var stateValue;
  if (typeof initArg === 'function') {
    stateValue = initArg();
  } else if (typeof init === 'function') {
    stateValue = init(initArg);
  } else {
    stateValue = initArg;
  }
  var hook = createHook();
  var trigger = TriggerAction.bind(null, getProcessingVNode(), hook, isUseState);
  // 为hook.state赋值{状态值, 触发函数, reducer, updates更新数组, 是否是useState}
  hook.state = {
    stateValue: stateValue,
    trigger: trigger,
    reducer: reducer,
    updates: null,
    isUseState: isUseState
  };
  return [hook.state.stateValue, trigger];
}

// 更新hook.state
function updateReducerHookState(currentHookUpdates, currentHook, reducer) {
  if (currentHookUpdates !== null) {
    // 循环遍历更新数组，计算新的状态值
    var newState = calculateNewState(currentHookUpdates, currentHook, reducer);
    if (!isSame$1(newState, currentHook.state.stateValue)) {
      setStateChange(true);
    }

    // 更新hook对象状态值
    currentHook.state.stateValue = newState;
    // 重置更新数组为null
    currentHook.state.updates = null;
  }
  currentHook.state.reducer = reducer;
  return [currentHook.state.stateValue, currentHook.state.trigger];
}

// 计算stateValue值
function calculateNewState(currentHookUpdates, currentHook, reducer) {
  var reducerObj = currentHook.state;
  var state = reducerObj.stateValue;

  // 循环遍历更新数组，计算新的状态值
  currentHookUpdates.forEach(function (update) {
    // 1. didCalculated = true 说明state已经计算过; 2. 如果来自 isUseState
    if (update.didCalculated && reducerObj.isUseState) {
      state = update.state;
    } else {
      var action = update.action;
      state = reducer(state, action);
    }
  });
  return state;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function defaultReducer(state, action) {
  // @ts-ignore
  return typeof action === 'function' ? action(state) : action;
}
function useStateImpl(initArg) {
  return useReducerImpl(defaultReducer, initArg, undefined, true);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function useContext(Context) {
  var processingVNode = getProcessingVNode();
  return getNewContext(processingVNode, Context, true);
}
function useState(initialState) {
  return useStateImpl(initialState);
}
function useReducer(reducer, initialArg, init) {
  return useReducerImpl(reducer, initialArg, init);
}
function useRef(initialValue) {
  return useRefImpl(initialValue);
}
function useEffect(create, deps) {
  return useEffectImpl(create, deps);
}
function useLayoutEffect(create, deps) {
  return useLayoutEffectImpl(create, deps);
}
function useRenderEffect(create, deps) {
  return useRenderEffectImpl(create, deps);
}
function useCallback(callback, deps) {
  return useCallbackImpl(callback, deps);
}
function useMemo(create, deps) {
  return useMemoImpl(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  return useImperativeHandleImpl(ref, create, deps);
}

// 兼容react-redux
var useDebugValue = function () {};

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function isObject$1(obj) {
  var type = typeof obj;
  return (obj !== null || obj !== undefined) && (type === 'object' || type === 'function');
}
function isSet(obj) {
  return (obj !== null || obj !== undefined) && (Object.prototype.toString.call(obj) === '[object Set]' || obj.constructor === Set);
}
function isWeakSet(obj) {
  return (obj !== null || obj !== undefined) && (Object.prototype.toString.call(obj) === '[object WeakSet]' || obj.constructor === WeakSet);
}
function isMap(obj) {
  return (obj !== null || obj !== undefined) && (Object.prototype.toString.call(obj) === '[object Map]' || obj.constructor === Map);
}
function isWeakMap(obj) {
  return (obj !== null || obj !== undefined) && (Object.prototype.toString.call(obj) === '[object WeakMap]' || obj.constructor === WeakMap);
}
function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
}
function isCollection(obj) {
  return isSet(obj) || isWeakSet(obj) || isMap(obj) || isWeakMap(obj);
}
function isString(obj) {
  return typeof obj === 'string';
}

// key是有效的正整数字的字符串
function isValidIntegerKey(key) {
  return isString(key) && key !== 'NaN' && key[0] !== '-' && String(parseInt(key, 10)) === key;
}
function isPromise$1(obj) {
  return isObject$1(obj) && typeof obj.then === 'function';
}
function isSame(x, y) {
  if (!(typeof Object.is === 'function')) {
    if (x === y) {
      // +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // NaN == NaN
      return x !== x && y !== y;
    }
  } else {
    return Object.is(x, y);
  }
}
function getDetailedType(val) {
  if (val === undefined) return 'undefined';
  if (val === null) return 'null';
  if (isCollection(val)) return 'collection';
  if (isPromise$1(val)) return 'promise';
  if (isArray(val)) return 'array';
  if (isWeakMap(val)) return 'weakMap';
  if (isMap(val)) return 'map';
  if (isWeakSet(val)) return 'weakSet';
  if (isSet(val)) return 'set';
  return typeof val;
}
function resolveMutation(from, to) {
  if (getDetailedType(from) !== getDetailedType(to)) {
    return {
      mutation: true,
      from: from,
      to: to
    };
  }
  switch (getDetailedType(from)) {
    case 'array':
      {
        var len = Math.max(from.length, to.length);
        var res = [];
        var found = false;
        for (var i = 0; i < len; i++) {
          if (from.length <= i) {
            res[i] = {
              mutation: true,
              to: to[i]
            };
            found = true;
          } else if (to.length <= i) {
            res[i] = {
              mutation: true,
              from: from[i]
            };
            found = true;
          } else {
            res[i] = resolveMutation(from[i], to[i]);
            if (res[i].mutation) found = true;
          }
        }
        // TODO: resolve shifts
        return {
          mutation: found,
          items: res,
          from: from,
          to: to
        };
      }
    case 'object':
      {
        var keys = Object.keys(_extends({}, from, to));
        var _res = {};
        var _found = false;
        keys.forEach(function (key) {
          if (!(key in from)) {
            _res[key] = {
              mutation: true,
              to: to[key]
            };
            _found = true;
            return;
          }
          if (!(key in to)) {
            _res[key] = {
              mutation: true,
              from: from[key]
            };
            _found = true;
            return;
          }
          _res[key] = resolveMutation(from[key], to[key]);
          if (_res[key].mutation) _found = true;
        });
        return {
          mutation: _found,
          attributes: _res,
          from: from,
          to: to
        };
      }

    // TODO: implement collections

    default:
      {
        if (from === to) return {
          mutation: false
        };
        return {
          mutation: true,
          from: from,
          to: to
        };
      }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

var OBSERVER_KEY = '_horizonObserver';

var INITIALIZED = 'horizonx store initialized';
var STATE_CHANGE = 'horizonx state change';
var SUBSCRIBED = 'horizonx subscribed';
var UNSUBSCRIBED = 'horizonx unsubscribed';
var ACTION = 'horizonx action';
var ACTION_QUEUED = 'horizonx action queued';
var OBSERVED_COMPONENTS = 'horizonx observed components';

var sessionId = Date.now();

// this function is used to detect devtool connection
function isPanelActive() {
  return window['__HORIZON_DEV_HOOK__'];
}

// serializes store and creates expanded object with baked-in containing current computed values
function makeStoreSnapshot(_ref) {
  var type = _ref.type,
    data = _ref.data;
  var expanded = {};
  Object.keys(data.store.$c).forEach(function (key) {
    expanded[key] = data.store[key];
  });
  data.store.expanded = expanded;
  var snapshot = makeProxySnapshot({
    data: data,
    type: type,
    sessionId: sessionId
  });
  return snapshot;
}

// safely serializes variables containing values wrapped in Proxy object
function makeProxySnapshot(obj) {
  var clone;
  try {
    if (!obj) {
      return obj;
    }
    if (obj.nativeEvent) return obj.type + 'Event';
    if (typeof obj === 'function') {
      return obj.toString();
    }
    if (Array.isArray(obj)) {
      clone = [];
      obj.forEach(function (item) {
        return clone.push(makeProxySnapshot(item));
      });
      return clone;
    } else if (typeof obj === 'object') {
      clone = {};
      Object.entries(obj).forEach(function (_ref2) {
        var id = _ref2[0],
          value = _ref2[1];
        return clone[id] = makeProxySnapshot(value);
      });
      return clone;
    }
    return obj;
  } catch (err) {
    throw console.log('cannot serialize object. ' + err);
  }
}
var devtools = {
  // returns vNode id from horizon devtools
  getVNodeId: function (vNode) {
    if (!isPanelActive()) return;
    getVNodeId(vNode);
  },
  emit: function (type, data) {
    if (!isPanelActive()) return;
    window.postMessage({
      type: 'HORIZON_DEV_TOOLS',
      payload: makeStoreSnapshot({
        type: type,
        data: data
      }),
      from: 'dev tool hook'
    });
  }
};

// collects components that are dependant on horizonx store and their ids
function getAffectedComponents() {
  var allStores = getAllStores();
  var keys = Object.keys(allStores);
  var res = {};
  keys.forEach(function (key) {
    var subRes = new Set();
    var process = Array.from(allStores[key].$config.state._horizonObserver.keyVNodes.values());
    while (process.length) {
      var pivot = process.shift();
      if (pivot !== null && pivot !== void 0 && pivot.tag) subRes.add(pivot);
      if ((pivot === null || pivot === void 0 ? void 0 : pivot.toString()) === '[object Set]') Array.from(pivot).forEach(function (item) {
        return process.push(item);
      });
    }
    res[key] = Array.from(subRes).map(function (vnode) {
      return {
        name: vnode === null || vnode === void 0 ? void 0 : vnode.type.toString().replace(/\{.*\}/gms, '{...}').replace('function ', ''),
        nodeId: window.__HORIZON_DEV_HOOK__.getVnodeId(vnode)
      };
    });
  });
  return res;
}

// listens to messages from background
window.addEventListener('message', function (messageEvent) {
  var _messageEvent$data, _messageEvent$data$pa, _messageEvent$data2, _messageEvent$data2$p;
  if ((messageEvent === null || messageEvent === void 0 ? void 0 : (_messageEvent$data = messageEvent.data) === null || _messageEvent$data === void 0 ? void 0 : (_messageEvent$data$pa = _messageEvent$data.payload) === null || _messageEvent$data$pa === void 0 ? void 0 : _messageEvent$data$pa.type) === 'horizonx request observed components') {
    // get observed components
    setTimeout(function () {
      window.postMessage({
        type: 'HORIZON_DEV_TOOLS',
        payload: {
          type: OBSERVED_COMPONENTS,
          data: getAffectedComponents()
        },
        from: 'dev tool hook'
      });
    }, 100);
  }

  // executes store action
  if (((_messageEvent$data2 = messageEvent.data) === null || _messageEvent$data2 === void 0 ? void 0 : (_messageEvent$data2$p = _messageEvent$data2.payload) === null || _messageEvent$data2$p === void 0 ? void 0 : _messageEvent$data2$p.type) === 'horizonx executue action') {
    var data = messageEvent.data.payload.data;
    var store = getStore(data.storeId);
    if (!(store !== null && store !== void 0 && store[data.action])) return;
    var action = store[data.action];
    var params = data.params;
    action.apply(void 0, params);
  }
});
function getVNodeId(vNode) {
  window['__HORIZON_DEV_HOOK__'].send();
  return window['__HORIZON_DEV_HOOK__'].getVnodeId(vNode);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createObjectProxy(rawObj) {
  var singleLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var proxy = new Proxy(rawObj, {
    get: function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return get$2.apply(void 0, args.concat([singleLevel]));
    },
    set: set$2
  });
  return proxy;
}
function get$2(rawObj, key, receiver) {
  var singleLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // The observer object of symbol ('_horizonObserver') cannot be accessed from Proxy to prevent errors caused by clonedeep.
  if (key === OBSERVER_KEY) {
    return undefined;
  }
  var observer = getObserver(rawObj);
  if (key === 'watch') {
    return function (prop, handler) {
      if (!observer.watchers[prop]) {
        observer.watchers[prop] = [];
      }
      observer.watchers[prop].push(handler);
      return function () {
        observer.watchers[prop] = observer.watchers[prop].filter(function (cb) {
          return cb !== handler;
        });
      };
    };
  }
  if (key === 'addListener') {
    return observer.addListener.bind(observer);
  }
  if (key === 'removeListener') {
    return observer.removeListener.bind(observer);
  }
  observer.useProp(key);
  var value = Reflect.get(rawObj, key, receiver);

  // 对于prototype不做代理
  if (key !== 'prototype') {
    // 对于value也需要进一步代理
    var valProxy = singleLevel ? value : createProxy(value, hookObserverMap.get(rawObj));
    return valProxy;
  }
  return value;
}
function set$2(rawObj, key, value, receiver) {
  var oldObject = isPanelActive() ? JSON.parse(JSON.stringify(rawObj)) : null;
  var observer = getObserver(rawObj);
  if (value && key == 'removeListener') {
    observer.removeListener(value);
  }
  var oldValue = rawObj[key];
  var newValue = value;
  var ret = Reflect.set(rawObj, key, newValue, receiver);
  var mutation = isPanelActive() ? resolveMutation(oldObject, rawObj) : {
    mutation: true,
    from: null,
    to: rawObj
  };
  if (!isSame(newValue, oldValue)) {
    var _observer$watchers;
    if ((_observer$watchers = observer.watchers) !== null && _observer$watchers !== void 0 && _observer$watchers[key]) {
      observer.watchers[key].forEach(function (cb) {
        cb(key, oldValue, newValue, mutation);
      });
    }
    observer.setProp(key, mutation);
  }
  return ret;
}

/**
 * 一个对象（对象、数组、集合）对应一个Observer
 */
var Observer = /*#__PURE__*/function () {
  function Observer() {
    _classCallCheck(this, Observer);
    this.vNodeKeys = new WeakMap();
    this.keyVNodes = new Map();
    this.listeners = [];
    this.watchers = {};
  }
  _createClass(Observer, [{
    key: "useProp",
    value:
    // 对象的属性被使用时调用
    function useProp(key) {
      var processingVNode = getProcessingVNode();
      if (processingVNode === null || !processingVNode.observers) {
        // 异常场景
        return;
      }

      // vNode -> Observers
      processingVNode.observers.add(this);

      // key -> vNodes，记录这个prop被哪些VNode使用了
      var vNodes = this.keyVNodes.get(key);
      if (!vNodes) {
        vNodes = new Set();
        this.keyVNodes.set(key, vNodes);
      }
      vNodes.add(processingVNode);

      // vNode -> keys，记录这个VNode使用了哪些props
      var keys = this.vNodeKeys.get(processingVNode);
      if (!keys) {
        keys = new Set();
        this.vNodeKeys.set(processingVNode, keys);
      }
      keys.add(key);
    }

    // 对象的属性被赋值时调用
  }, {
    key: "setProp",
    value: function setProp(key, mutation) {
      var _this = this;
      var vNodes = this.keyVNodes.get(key);
      //NOTE: using Set directly can lead to deadlock
      var vNodeArray = Array.from(vNodes || []);
      vNodeArray === null || vNodeArray === void 0 ? void 0 : vNodeArray.forEach(function (vNode) {
        if (vNode.isStoreChange) {
          // VNode已经被触发过，不再重复触发
          return;
        }
        vNode.isStoreChange = true;

        // 触发vNode更新
        _this.triggerUpdate(vNode);
      });

      // NOTE: mutations are different in dev and production.
      this.triggerChangeListeners({
        mutation: mutation,
        vNodes: vNodes
      });
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate(vNode) {
      if (!vNode) {
        return;
      }

      // 触发VNode更新
      launchUpdateFromVNode(vNode);
    }
  }, {
    key: "addListener",
    value: function addListener(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function removeListener(listener) {
      this.listeners = this.listeners.filter(function (item) {
        return item != listener;
      });
    }
  }, {
    key: "triggerChangeListeners",
    value: function triggerChangeListeners(_ref) {
      var mutation = _ref.mutation,
        vNodes = _ref.vNodes;
      var nodesList = vNodes ? Array.from(vNodes) : [];
      this.listeners.forEach(function (listener) {
        return listener({
          mutation: mutation,
          vNodes: nodesList.map(function (vNode) {
            var _vNode$type, _realNode, _realNode$outerHTML;
            var realNode = vNode.realNode;
            var searchedNode = vNode;
            while (!realNode) {
              searchedNode = searchedNode.child;
              realNode = searchedNode.realNode;
            }
            return {
              type: vNode === null || vNode === void 0 ? void 0 : (_vNode$type = vNode.type) === null || _vNode$type === void 0 ? void 0 : _vNode$type.name,
              id: devtools.getVNodeId(vNode),
              path: vNode.path,
              element: (_realNode = realNode) === null || _realNode === void 0 ? void 0 : (_realNode$outerHTML = _realNode.outerHTML) === null || _realNode$outerHTML === void 0 ? void 0 : _realNode$outerHTML.substr(0, 100)
            };
          })
        });
      });
    }

    // 触发所有使用的props的VNode更新
  }, {
    key: "allChange",
    value: function allChange() {
      var keyIt = this.keyVNodes.keys();
      var keyItem = keyIt.next();
      while (!keyItem.done) {
        this.setProp(keyItem.value, {});
        keyItem = keyIt.next();
      }
    }

    // 删除Observer中保存的这个VNode的关系数据
  }, {
    key: "clearByVNode",
    value: function clearByVNode(vNode) {
      var _this2 = this;
      var keys = this.vNodeKeys.get(vNode);
      if (keys) {
        keys.forEach(function (key) {
          var vNodes = _this2.keyVNodes.get(key);
          vNodes.delete(vNode);
          if (vNodes.size === 0) {
            _this2.keyVNodes.delete(key);
          }
        });
      }
      this.vNodeKeys.delete(vNode);
    }
  }]);
  return Observer;
}();

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

/**
 * 一个对象（对象、数组、集合）对应一个Observer
 */
var HooklessObserver = /*#__PURE__*/function () {
  function HooklessObserver() {
    _classCallCheck(this, HooklessObserver);
    this.listeners = [];
  }
  _createClass(HooklessObserver, [{
    key: "useProp",
    value: function useProp(key) {}
  }, {
    key: "addListener",
    value: function addListener(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function removeListener(listener) {
      this.listeners = this.listeners.filter(function (item) {
        return item != listener;
      });
    }
  }, {
    key: "setProp",
    value: function setProp(key, mutation) {
      this.triggerChangeListeners(mutation);
    }
  }, {
    key: "triggerChangeListeners",
    value: function triggerChangeListeners(mutation) {
      this.listeners.forEach(function (listener) {
        if (!listener) {
          return;
        }
        listener(mutation);
      });
    }
  }, {
    key: "triggerUpdate",
    value: function triggerUpdate(vNode) {}
  }, {
    key: "allChange",
    value: function allChange() {}
  }, {
    key: "clearByVNode",
    value: function clearByVNode(vNode) {}
  }]);
  return HooklessObserver;
}();

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createArrayProxy(rawObj) {
  var handle = {
    get: get$1,
    set: set$1
  };
  return new Proxy(rawObj, handle);
}
function get$1(rawObj, key, receiver) {
  if (key === 'watch') {
    var observer = getObserver(rawObj);
    return function (prop, handler) {
      if (!observer.watchers[prop]) {
        observer.watchers[prop] = [];
      }
      observer.watchers[prop].push(handler);
      return function () {
        observer.watchers[prop] = observer.watchers[prop].filter(function (cb) {
          return cb !== handler;
        });
      };
    };
  }
  if (isValidIntegerKey(key) || key === 'length') {
    return get$2(rawObj, key, receiver);
  }
  return Reflect.get(rawObj, key, receiver);
}
function set$1(rawObj, key, value, receiver) {
  var oldValue = rawObj[key];
  var oldLength = rawObj.length;
  var newValue = value;
  var oldArray = isPanelActive() ? JSON.parse(JSON.stringify(rawObj)) : null;
  var ret = Reflect.set(rawObj, key, newValue, receiver);
  var newLength = rawObj.length;
  var observer = getObserver(rawObj);
  var mutation = isPanelActive() ? resolveMutation(oldArray, rawObj) : {
    mutation: true,
    from: [],
    to: rawObj
  };
  if (!isSame(newValue, oldValue)) {
    var _observer$watchers;
    // 值不一样，触发监听器
    if ((_observer$watchers = observer.watchers) !== null && _observer$watchers !== void 0 && _observer$watchers[key]) {
      observer.watchers[key].forEach(function (cb) {
        cb(key, oldValue, newValue, mutation);
      });
    }

    // 触发属性变化
    observer.setProp(key, mutation);
  }
  if (oldLength !== newLength) {
    // 触发数组的大小变化
    observer.setProp('length', mutation);
  }
  return ret;
}

var COLLECTION_CHANGE = '_collectionChange';
var handler = _defineProperty({
  get: get,
  set: set,
  add: add,
  delete: deleteFun,
  clear: clear,
  has: has,
  entries: entries,
  forEach: forEach,
  keys: keys,
  values: values
}, typeof Symbol === 'function' ? Symbol.iterator : '@@iterator', forOf);
function createCollectionProxy(rawObj) {
  var hookObserver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var boundHandler = {};
  Object.entries(handler).forEach(function (_ref) {
    var id = _ref[0],
      val = _ref[1];
    boundHandler[id] = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return val.apply(void 0, args.concat([hookObserver]));
    };
  });
  return new Proxy(rawObj, _extends({}, boundHandler));
}
function get(rawObj, key, receiver) {
  if (key === 'size') {
    return size(rawObj);
  } else if (key === 'get') {
    return getFun.bind(null, rawObj);
  } else if (Object.prototype.hasOwnProperty.call(handler, key)) {
    var _value = Reflect.get(handler, key, receiver);
    return _value.bind(null, rawObj);
  } else if (key === 'watch') {
    var observer = getObserver(rawObj);
    return function (prop, handler) {
      if (!observer.watchers[prop]) {
        observer.watchers[prop] = [];
      }
      observer.watchers[prop].push(handler);
      return function () {
        observer.watchers[prop] = observer.watchers[prop].filter(function (cb) {
          return cb !== handler;
        });
      };
    };
  }
  return Reflect.get(rawObj, key, receiver);
}
function getFun(rawObj, key) {
  var observer = getObserver(rawObj);
  observer.useProp(key);
  var value = rawObj.get(key);
  // 对于value也需要进一步代理
  var valProxy = createProxy(value, hookObserverMap.get(rawObj));
  return valProxy;
}

// Map的set方法
function set(rawObj, key, value) {
  var oldValue = rawObj.get(key);
  var newValue = value;
  rawObj.set(key, newValue);
  var valChange = !isSame(newValue, oldValue);
  var observer = getObserver(rawObj);
  var mutation = isPanelActive() ? resolveMutation(oldValue, rawObj) : {
    mutation: true,
    from: null,
    to: rawObj
  };
  if (valChange || !rawObj.has(key)) {
    observer.setProp(COLLECTION_CHANGE, mutation);
  }
  if (valChange) {
    var _observer$watchers;
    if ((_observer$watchers = observer.watchers) !== null && _observer$watchers !== void 0 && _observer$watchers[key]) {
      observer.watchers[key].forEach(function (cb) {
        cb(key, oldValue, newValue, mutation);
      });
    }
    observer.setProp(key, mutation);
  }
  return rawObj;
}

// Set的add方法
function add(rawObj, value) {
  var oldCollection = isPanelActive() ? JSON.parse(JSON.stringify(rawObj)) : null;
  if (!rawObj.has(value)) {
    rawObj.add(value);
    var observer = getObserver(rawObj);
    var mutation = isPanelActive() ? resolveMutation(oldCollection, rawObj) : {
      mutation: true,
      from: null,
      to: rawObj
    };
    observer.setProp(value, mutation);
    observer.setProp(COLLECTION_CHANGE, mutation);
  }
  return rawObj;
}
function has(rawObj, key) {
  var observer = getObserver(rawObj);
  observer.useProp(key);
  return rawObj.has(key);
}
function clear(rawObj) {
  var oldSize = rawObj.size;
  rawObj.clear();
  if (oldSize > 0) {
    var observer = getObserver(rawObj);
    observer.allChange();
  }
}
function deleteFun(rawObj, key) {
  var oldCollection = isPanelActive() ? JSON.parse(JSON.stringify(rawObj)) : null;
  if (rawObj.has(key)) {
    rawObj.delete(key);
    var observer = getObserver(rawObj);
    var mutation = isPanelActive() ? resolveMutation(oldCollection, rawObj) : {
      mutation: true,
      from: null,
      to: rawObj
    };
    observer.setProp(key, mutation);
    observer.setProp(COLLECTION_CHANGE, mutation);
    return true;
  }
  return false;
}
function size(rawObj) {
  var observer = getObserver(rawObj);
  observer.useProp(COLLECTION_CHANGE);
  return rawObj.size;
}
function keys(rawObj) {
  return wrapIterator(rawObj, rawObj.keys());
}
function values(rawObj) {
  return wrapIterator(rawObj, rawObj.values());
}
function entries(rawObj) {
  return wrapIterator(rawObj, rawObj.entries(), true);
}
function forOf(rawObj) {
  var isMapType = isMap(rawObj) || isWeakMap(rawObj);
  var iterator = isMapType ? rawObj.entries() : rawObj.values();
  return wrapIterator(rawObj, iterator, isMapType);
}
function forEach(rawObj, callback) {
  var observer = getObserver(rawObj);
  observer.useProp(COLLECTION_CHANGE);
  rawObj.forEach(function (value, key) {
    var valProxy = createProxy(value, hookObserverMap.get(rawObj));
    var keyProxy = createProxy(key, hookObserverMap.get(rawObj));
    // 最后一个参数要返回代理对象
    return callback(valProxy, keyProxy, rawObj);
  });
}
function wrapIterator(rawObj, rawIt) {
  var isPair = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var observer = getObserver(rawObj);
  var hookObserver = hookObserverMap.get(rawObj);
  observer.useProp(COLLECTION_CHANGE);
  return _defineProperty({
    next: function () {
      var _rawIt$next = rawIt.next(),
        value = _rawIt$next.value,
        done = _rawIt$next.done;
      if (done) {
        return {
          value: createProxy(value, hookObserver),
          done: done
        };
      }
      observer.useProp(COLLECTION_CHANGE);
      var newVal;
      if (isPair) {
        newVal = [createProxy(value[0], hookObserver), createProxy(value[1], hookObserver)];
      } else {
        newVal = createProxy(value, hookObserver);
      }
      return {
        value: newVal,
        done: done
      };
    }
  }, typeof Symbol === 'function' ? Symbol.iterator : '@@iterator', function () {
    return this;
  });
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 保存rawObj -> Proxy
var proxyMap = new WeakMap();
var hookObserverMap = new WeakMap();
function createProxy(rawObj, id) {
  var isHookObserver = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // 不是对象（是原始数据类型）不用代理
  if (!(rawObj && isObject$1(rawObj))) {
    return rawObj;
  }

  // 已代理过
  var existProxy = proxyMap.get(rawObj);
  if (existProxy) {
    return existProxy;
  }

  // Observer不需要代理
  if (rawObj instanceof Observer) {
    return rawObj;
  }

  // 创建Observer
  var observer = getObserver(rawObj);
  if (!observer) {
    observer = isHookObserver ? new Observer() : new HooklessObserver();
    rawObj[OBSERVER_KEY] = observer;
  }
  hookObserverMap.set(rawObj, isHookObserver);

  // 创建Proxy
  var proxyObj;
  if (!isHookObserver) {
    proxyObj = createObjectProxy(rawObj, true);
  } else if (isArray(rawObj)) {
    // 数组
    proxyObj = createArrayProxy(rawObj);
  } else if (isCollection(rawObj)) {
    // 集合
    proxyObj = createCollectionProxy(rawObj);
  } else {
    // 原生对象 或 函数
    proxyObj = createObjectProxy(rawObj);
  }
  proxyMap.set(rawObj, proxyObj);
  proxyMap.set(proxyObj, proxyObj);
  return proxyObj;
}
function getObserver(rawObj) {
  return rawObj[OBSERVER_KEY];
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function readonlyProxy(rawObj) {
  return new Proxy(rawObj, {
    get: function (rawObj, property, receiver) {
      var result = Reflect.get(rawObj, property, receiver);
      try {
        if (isObject$1(result)) {
          return readonlyProxy(result);
        }
      } catch (err) {
        // 不处理
      }
      return result;
    },
    set: function () {
      throw Error('Trying to change readonly variable');
    },
    deleteProperty: function () {
      throw Error('Trying to change readonly variable');
    }
  });
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var idGenerator = {
  id: 0,
  get: function (prefix) {
    return prefix.toString() + this.id++;
  }
};
var storeMap = new Map();
function createStore$1(config) {
  var _config$options;
  // 校验
  if (Object.prototype.toString.call(config) !== '[object Object]') {
    throw new Error('store obj must be pure object');
  }
  var id = config.id || idGenerator.get('UNNAMED_STORE');
  var proxyObj = createProxy(config.state, id, !((_config$options = config.options) !== null && _config$options !== void 0 && _config$options.isReduxAdapter));
  proxyObj.$pending = false;
  var $a = {};
  var $queue = {};
  var $c = {};
  var storeObj = {
    id: id,
    $s: proxyObj,
    $a: $a,
    $c: $c,
    $queue: $queue,
    $config: config,
    $subscribe: function (listener) {
      devtools.emit(SUBSCRIBED, {
        store: storeObj,
        listener: listener
      });
      proxyObj.addListener(listener);
    },
    $unsubscribe: function (listener) {
      devtools.emit(UNSUBSCRIBED, storeObj);
      proxyObj.removeListener(listener);
    }
  };
  var plannedActions = [];

  // 包装actions
  if (config.actions) {
    Object.keys(config.actions).forEach(function (action) {
      // 让store.$queue[action]可以访问到action方法
      // 要达到的效果：如果通过store.$queue[action1]调用的action1返回promise,会阻塞下一个store.$queue[action2]
      $queue[action] = function () {
        for (var _len = arguments.length, payload = new Array(_len), _key = 0; _key < _len; _key++) {
          payload[_key] = arguments[_key];
        }
        devtools.emit(ACTION_QUEUED, {
          store: storeObj,
          action: {
            action: action,
            payload: payload
          },
          fromQueue: true
        });
        return new Promise(function (resolve) {
          if (!proxyObj.$pending) {
            proxyObj.$pending = true;
            var result = config.actions[action].bind(storeObj, proxyObj).apply(void 0, payload);
            if (isPromise$1(result)) {
              result.then(function (value) {
                resolve(value);
                tryNextAction(storeObj, proxyObj, config, plannedActions);
              });
            } else {
              resolve(result);
              tryNextAction(storeObj, proxyObj, config, plannedActions);
            }
          } else {
            // 加入队列
            plannedActions.push({
              action: action,
              payload: payload,
              resolve: resolve
            });
          }
        });
      };

      // 让store.$a[action]可以访问到action方法
      $a[action] = function Wrapped() {
        for (var _len2 = arguments.length, payload = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          payload[_key2] = arguments[_key2];
        }
        devtools.emit(ACTION, {
          store: storeObj,
          action: {
            action: action,
            payload: payload
          },
          fromQueue: false
        });
        return config.actions[action].bind(storeObj, proxyObj).apply(void 0, payload);
      };

      // 让store[action]可以访问到action方法
      Object.defineProperty(storeObj, action, {
        writable: false,
        value: function () {
          for (var _len3 = arguments.length, payload = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            payload[_key3] = arguments[_key3];
          }
          devtools.emit(ACTION, {
            store: storeObj,
            action: {
              action: action,
              payload: payload
            },
            fromQueue: false
          });
          return config.actions[action].bind(storeObj, proxyObj).apply(void 0, payload);
        }
      });
    });
  }
  if (config.computed) {
    Object.keys(config.computed).forEach(function (computeKey) {
      // 让store.$c[computeKey]可以访问到computed方法
      $c[computeKey] = config.computed[computeKey].bind(storeObj, readonlyProxy(proxyObj));

      // 让store[computeKey]可以访问到computed的值
      Object.defineProperty(storeObj, computeKey, {
        get: $c[computeKey]
      });
    });
  }

  // 让store[key]可以访问到state的值
  if (config.state) {
    Object.keys(config.state).forEach(function (key) {
      Object.defineProperty(storeObj, key, {
        get: function () {
          // 从Proxy对象获取值，会触发代理
          return proxyObj[key];
        },
        set: function (value) {
          proxyObj[key] = value;
        }
      });
    });
  }
  storeMap.set(id, storeObj);
  devtools.emit(INITIALIZED, {
    store: storeObj
  });
  proxyObj.addListener(function (change) {
    devtools.emit(STATE_CHANGE, {
      store: storeObj,
      change: change
    });
  });
  return createGetStore(storeObj);
}

// 通过该方法执行store.$queue中的action
function tryNextAction(storeObj, proxyObj, config, plannedActions) {
  if (!plannedActions.length) {
    proxyObj.$pending = false;
    return;
  }
  var nextAction = plannedActions.shift();
  var result = config.actions ? config.actions[nextAction.action].bind(storeObj, proxyObj).apply(void 0, nextAction.payload) : undefined;
  if (isPromise$1(result)) {
    result.then(function (value) {
      nextAction.resolve(value);
      tryNextAction(storeObj, proxyObj, config, plannedActions);
    });
  } else {
    nextAction.resolve(result);
    tryNextAction(storeObj, proxyObj, config, plannedActions);
  }
}

// createStore返回的是一个getStore的函数，这个函数必须要在组件（函数/类组件）里面被执行，因为要注册VNode销毁时的清理动作
function createGetStore(storeObj) {
  var getStore = function () {
    var _storeObj$$config$opt;
    if (!((_storeObj$$config$opt = storeObj.$config.options) !== null && _storeObj$$config$opt !== void 0 && _storeObj$$config$opt.isReduxAdapter)) {
      registerDestroyFunction();
    }
    return storeObj;
  };
  return getStore;
}

// 删除Observers中保存的这个VNode的相关数据
function clearVNodeObservers(vNode) {
  if (!vNode.observers) {
    return;
  }
  vNode.observers.forEach(function (observer) {
    observer.clearByVNode(vNode);
  });
  vNode.observers.clear();
}

// 注册VNode销毁时的清理动作
function registerDestroyFunction() {
  var processingVNode = getProcessingVNode();

  // 获取不到当前运行的VNode，说明不在组件中运行，属于非法场景
  if (!processingVNode) {
    return;
  }
  if (!processingVNode.observers) {
    processingVNode.observers = new Set();
  }

  // 函数组件
  if (processingVNode.tag === FunctionComponent) {
    var vNodeRef = useRef(processingVNode);
    useEffect(function () {
      return function () {
        clearVNodeObservers(vNodeRef.current);
        vNodeRef.current.observers = null;
      };
    }, []);
  } else if (processingVNode.tag === ClassComponent) {
    // 类组件
    if (!processingVNode.classComponentWillUnmount) {
      processingVNode.classComponentWillUnmount = function (vNode) {
        clearVNodeObservers(vNode);
        vNode.observers = null;
      };
    }
  }
}

// 函数组件中使用的hook
function useStore$1(id) {
  var _storeObj$$config$opt2;
  var storeObj = storeMap.get(id);
  if (storeObj && !((_storeObj$$config$opt2 = storeObj.$config.options) !== null && _storeObj$$config$opt2 !== void 0 && _storeObj$$config$opt2.isReduxAdapter)) {
    registerDestroyFunction();
  }
  return storeObj;
}
function getStore(id) {
  return storeMap.get(id);
}
function getAllStores() {
  return Object.fromEntries(storeMap);
}
function clearStore(id) {
  storeMap.delete(id);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 复用vNode时，也需对树的上下文值处理，如context，portal, namespaceContext
function setTreeContextValue(processing) {
  switch (processing.tag) {
    case TreeRoot:
      setNamespaceCtx(processing, processing.realNode);
      break;
    case DomComponent:
      setNamespaceCtx(processing);
      break;
    case DomPortal:
      setNamespaceCtx(processing, processing.realNode);
      pushCurrentRoot(processing);
      break;
    case ContextProvider:
      {
        var newValue = processing.props.value;
        setContext(processing, newValue);
        break;
      }
    // No Default
  }
}

function captureVNode(processing) {
  var _processing$props;
  var component = componentRenders[processing.tag];
  if (processing.tag !== SuspenseComponent) {
    // 该vNode没有变化，不用进入capture，直接复用。
    if (!processing.isCreated && processing.oldProps === processing.props && !processing.shouldUpdate) {
      // 复用还需对stack进行处理
      setTreeContextValue(processing);
      return onlyUpdateChildVNodes(processing);
    }
  }
  var shouldUpdate = processing.shouldUpdate;
  processing.shouldUpdate = false;
  setProcessingVNode(processing);
  if (processing.observers) clearVNodeObservers(processing);
  var child = component.captureRender(processing, shouldUpdate);
  setProcessingVNode(null);
  if (processing !== null && processing !== void 0 && (_processing$props = processing.props) !== null && _processing$props !== void 0 && _processing$props['propagate-css-scope']) {
    setTimeout(function () {
      function propagateCssScope(root, scope) {
        var leaveBoth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (!root) return;
        if (!leaveBoth) Object.keys(root.dataset).forEach(function (key) {
          return root.removeAttribute('data-' + key);
        });
        root.setAttribute(scope, true);
        Array.from(root.children).forEach(function (child) {
          return propagateCssScope(child, scope);
        });
      }
      propagateCssScope(processing === null || processing === void 0 ? void 0 : processing.realNode, processing.props['propagate-css-scope'], true);
    }, 1);
  }
  return child;
}
function markRef(processing) {
  var ref = processing.ref;
  if (processing.isCreated && ref !== null || !processing.isCreated && processing.oldRef !== ref) {
    FlagUtils.markRef(processing);
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function consoleError(error) {
  {
    console['error'](error);
  }
}
function handleRootError(error) {
  // 注意：如果根节点抛出错误，不会销毁整棵树，只打印日志，抛出异常。
  setRootThrowError(error);
  consoleError(error);
}
function createClassErrorUpdate(vNode, error) {
  var update = newUpdate();
  update.type = UpdateState.Error;
  var getDerivedStateFromError = vNode.type.getDerivedStateFromError;
  if (typeof getDerivedStateFromError === 'function') {
    update.content = function () {
      consoleError(error);
      return getDerivedStateFromError(error);
    };
  }
  var inst = vNode.realNode;
  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      if (typeof getDerivedStateFromError !== 'function') {
        // 打印错误
        consoleError(error);
      }

      // @ts-ignore
      this.componentDidCatch(error, {
        componentStack: ''
      });
    };
  }
  return update;
}
function isPromise(error) {
  return error !== null && typeof error === 'object' && typeof error.then === 'function';
}
// 处理capture和bubble阶段抛出的错误
function handleRenderThrowError(sourceVNode, error) {
  // vNode抛出了异常，标记Interrupted中断
  FlagUtils.markInterrupted(sourceVNode);
  // dirtyNodes 不再有效
  sourceVNode.dirtyNodes = null;

  // error是个promise
  if (isPromise(error)) {
    // 抛出异常的节点，向上寻找，是否有suspense组件
    var foundSuspense = handleSuspenseChildThrowError(sourceVNode.parent, sourceVNode, error);
    if (foundSuspense) {
      return;
    }
  }

  // 抛出错误无法作为suspense内容处理（或无suspense来处理），这次当成真的错误来处理
  setBuildResult(BuildErrored);

  // 向上遍历寻找ClassComponent组件（同时也是Error Boundaries组件） 或者 TreeRoot
  var vNode = sourceVNode.parent;
  do {
    switch (vNode.tag) {
      case TreeRoot:
        {
          vNode.shouldUpdate = true;
          launchUpdateFromVNode(vNode);
          handleRootError(error);
          return;
        }
      case ClassComponent:
        var ctor = vNode.type;
        var instance = vNode.realNode;
        if ((vNode.flags & DidCapture) === InitFlag && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function')) {
          FlagUtils.markShouldCapture(vNode);

          // Class捕捉到异常，触发一次刷新
          var update = createClassErrorUpdate(vNode, error);
          pushUpdate(vNode, update);
          launchUpdateFromVNode(vNode);

          // 有异常处理类，把抛出异常的节点的Interrupted标志去掉，继续走正常的绘制流程
          FlagUtils.removeFlag(sourceVNode, Interrupted);
          return;
        }
        break;
    }
    vNode = vNode.parent;
  } while (vNode !== null);
}

// 新增一个update，并且触发调度
function triggerUpdate(vNode, state) {
  var update = newUpdate();
  update.content = state;
  pushUpdate(vNode, update);
  var root = updateShouldUpdateOfTree(vNode);
  if (root !== null) {
    tryRenderFromRoot(root);
  }
}

// 处理submit阶段的异常
function handleSubmitError(vNode, error) {
  if (vNode.tag === TreeRoot) {
    handleRootError(error);
    return;
  }
  var node = vNode.parent;
  // 向上遍历
  while (node !== null) {
    if (node.tag === TreeRoot) {
      handleRootError(error);
      return;
    } else if (node.tag === ClassComponent) {
      // 只有 class 组件才可以成为错误边界组件
      var ctor = node.type;
      var instance = node.realNode;
      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function') {
        var getDerivedStateFromError = node.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === 'function') {
          // 打印错误
          consoleError(error);
          var retState = getDerivedStateFromError(error);
          if (retState) {
            // 有返回值
            // 触发更新
            triggerUpdate(node, retState);
          }
        }

        // 处理componentDidCatch
        if (instance !== null && typeof instance.componentDidCatch === 'function') {
          if (typeof getDerivedStateFromError !== 'function') {
            // 没有getDerivedStateFromError
            // 打印错误
            consoleError(error);
          }
          instance.componentDidCatch(error, {
            componentStack: ''
          });
        }
        return;
      }
    }
    node = node.parent;
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function callComponentWillUnmount(vNode, instance) {
  try {
    instance.componentWillUnmount();
  } catch (error) {
    handleSubmitError(vNode, error);
  }
}

// 调用界面变化前的生命周期
function callBeforeSubmitLifeCycles(vNode) {
  if (vNode.tag === ClassComponent && !vNode.isCreated) {
    // 调用instance.getSnapshotBeforeUpdate
    var prevProps = vNode.isLazyComponent ? mergeDefaultProps(vNode.type, vNode.oldProps) : vNode.oldProps;
    var prevState = vNode.oldState;
    var instance = vNode.realNode;
    var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);

    // __snapshotResult会在调用componentDidUpdate的时候作为第三个参数
    instance.__snapshotResult = snapshot;
  }
}

// 调用vNode.stateCallbacks
function callStateCallback(vNode, obj) {
  var stateCallbacks = vNode.stateCallbacks;
  vNode.stateCallbacks = null;
  if (stateCallbacks !== null) {
    stateCallbacks.forEach(function (callback) {
      if (typeof callback === 'function') {
        callback.call(obj);
      }
    });
  }
}

// 调用界面变化后的生命周期
function callAfterSubmitLifeCycles(vNode) {
  switch (vNode.tag) {
    case FunctionComponent:
    case ForwardRef:
      {
        // 执行useLayoutEffect的create方法
        callUseLayoutEffectCreate(vNode);
        callUseEffects(vNode);
        return;
      }
    case ClassComponent:
      {
        var instance = vNode.realNode;
        if ((vNode.flags & Update) === Update) {
          if (vNode.isCreated) {
            instance.componentDidMount();
          } else {
            var prevProps = vNode.isLazyComponent ? mergeDefaultProps(vNode.type, vNode.oldProps) : vNode.oldProps;
            var prevState = vNode.oldState;
            instance.componentDidUpdate(prevProps, prevState, instance.__snapshotResult);
          }
        }
        callStateCallback(vNode, instance);
        return;
      }
    case TreeRoot:
      {
        var _instance = vNode.child !== null ? vNode.child.realNode : null;
        callStateCallback(vNode, _instance);
        return;
      }
    case DomComponent:
      {
        if (vNode.isCreated && (vNode.flags & Update) === Update) {
          // button、input、select、textarea、如果有 autoFocus 属性需要focus
          if (shouldAutoFocus(vNode.type, vNode.props)) {
            vNode.realNode.focus();
          }
        }
      }

    // No Default
  }
}

function hideOrUnhideAllChildren(vNode, isHidden) {
  travelVNodeTree(vNode, function (node) {
    var instance = node.realNode;
    if (node.tag === DomComponent || node.tag === DomText) {
      if (isHidden) {
        hideDom(node.tag, instance);
      } else {
        unHideDom(node.tag, instance, node.props);
      }
    }
  }, null, vNode, null);
}
function attachRef(vNode) {
  var ref = vNode.ref;
  handleRef(vNode, ref, vNode.realNode);
}
function detachRef(vNode, isOldRef) {
  var ref = isOldRef ? vNode.oldRef : vNode.ref;
  handleRef(vNode, ref, null);
}
function handleRef(vNode, ref, val) {
  if (ref !== null && ref !== undefined) {
    var refType = typeof ref;
    if (refType === 'function') {
      ref(val);
    } else if (refType === 'object') {
      ref.current = val;
    } else {
      if (vNode.belongClassVNode && vNode.belongClassVNode.realNode) {
        vNode.belongClassVNode.realNode.refs[String(ref)] = val;
      }
    }
  }
}

// 卸载一个vNode，不会递归
function unmountVNode(vNode) {
  switch (vNode.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
      {
        callEffectRemove(vNode);
        break;
      }
    case ClassComponent:
      {
        detachRef(vNode);
        var instance = vNode.realNode;
        // 当constructor中抛出异常时，instance会是null，这里判断一下instance是否为空
        // suspense打断时不需要触发WillUnmount
        if (instance && typeof instance.componentWillUnmount === 'function' && !vNode.isSuspended) {
          callComponentWillUnmount(vNode, instance);
        }

        // HorizonX会在classComponentWillUnmount中清除对VNode的引入用
        if (vNode.classComponentWillUnmount) {
          vNode.classComponentWillUnmount(vNode);
          vNode.classComponentWillUnmount = null;
        }
        break;
      }
    case DomComponent:
      {
        detachRef(vNode);
        break;
      }
    case DomPortal:
      {
        // 这里会递归
        unmountDomComponents(vNode);
        break;
      }
  }
}

// 卸载vNode，递归遍历子vNode
function unmountNestedVNodes(vNode) {
  travelVNodeTree(vNode, function (node) {
    unmountVNode(node);
  }, function (node) {
    return (
      // 如果是DomPortal，不需要遍历child
      node.tag === DomPortal
    );
  }, vNode, null);
}
function submitAddition(vNode) {
  var parent = vNode.parent;
  var parentDom;
  var tag;
  while (parent !== null) {
    tag = parent.tag;
    if (tag === DomComponent || tag === TreeRoot || tag === DomPortal) {
      parentDom = parent.realNode;
      break;
    }
    parent = parent.parent;
  }
  if ((parent.flags & ResetText) === ResetText) {
    // 在insert之前先reset
    clearText(parentDom);
    FlagUtils.removeFlag(parent, ResetText);
  }
  if ((vNode.flags & DirectAddition) === DirectAddition) {
    insertOrAppendPlacementNode(vNode, null, parentDom);
    FlagUtils.removeFlag(vNode, DirectAddition);
    return;
  }
  var before = getSiblingDom(vNode);
  insertOrAppendPlacementNode(vNode, before, parentDom);
}
function insertOrAppendPlacementNode(node, beforeDom, parent) {
  var tag = node.tag,
    realNode = node.realNode;
  if (isDomVNode(node)) {
    insertDom(parent, realNode, beforeDom);
  } else if (tag === DomPortal) ; else {
    // 插入子节点们
    var child = node.child;
    while (child !== null) {
      insertOrAppendPlacementNode(child, beforeDom, parent);
      child = child.next;
    }
  }
}
function insertDom(parent, realNode, beforeDom) {
  if (beforeDom) {
    insertDomBefore(parent, realNode, beforeDom);
  } else {
    appendChildElement(parent, realNode);
  }
}

// 遍历所有子节点：删除dom节点，detach ref 和 调用componentWillUnmount()
function unmountDomComponents(vNode) {
  var currentParentIsValid = false;

  // 这两个变量要一起更新
  var currentParent;
  travelVNodeTree(vNode, function (node) {
    if (!currentParentIsValid) {
      var parent = node.parent;
      var tag;
      while (parent !== null) {
        tag = parent.tag;
        if (tag === DomComponent || tag === TreeRoot || tag === DomPortal) {
          currentParent = parent.realNode;
          break;
        }
        parent = parent.parent;
      }
      currentParentIsValid = true;
    }
    if (node.tag === DomComponent || node.tag === DomText) {
      // 卸载vNode，递归遍历子vNode
      unmountNestedVNodes(node);

      // 在所有子项都卸载后，删除dom树中的节点
      removeChildDom(currentParent, node.realNode);
    } else if (node.tag === DomPortal) {
      if (node.child !== null) {
        currentParent = node.realNode;
      }
    } else {
      unmountVNode(node);
    }
  }, function (node) {
    return (
      // 如果是dom不用再遍历child
      node.tag === DomComponent || node.tag === DomText
    );
  }, vNode, function (node) {
    if (node.tag === DomPortal) {
      // 当离开portal，需要重新设置parent
      currentParentIsValid = false;
    }
  });
}
function submitClear(vNode) {
  var realNode = vNode.realNode;
  var cloneDom = realNode.cloneNode(false); // 复制节点后horizon添加给dom的属性未能复制
  // 真实 dom 获取的keys只包含新增的属性
  // 比如真实 dom 拿到的 keys 一般只有两个 horizon 自定义属性
  // 但考虑到用户可能自定义其他属性，所以采用遍历赋值的方式
  var customizeKeys = Object.keys(realNode);
  var keyLength = customizeKeys.length;
  for (var i = 0; i < keyLength; i++) {
    var key = customizeKeys[i];
    // 测试代码 mock 实例的全部可遍历属性都会被Object.keys方法读取到
    // children 属性被复制意味着复制了子节点，因此要排除
    if (key !== 'children') {
      cloneDom[key] = realNode[key]; // 复制cloneNode未能复制的属性
    }
  }

  var parent = vNode.parent;
  var parentDom;
  var tag;
  while (parent !== null) {
    tag = parent.tag;
    if (tag === DomComponent || tag === TreeRoot || tag === DomPortal) {
      parentDom = parent.realNode;
      break;
    }
    parent = parent.parent;
  }
  var clearChild = vNode.clearChild; // 上次渲染的child保存在clearChild属性中
  // 卸载 clearChild 和 它的兄弟节点
  while (clearChild) {
    // 卸载子vNode，递归遍历子vNode
    unmountNestedVNodes(clearChild);
    clearVNode(clearChild);
    clearChild = clearChild.next;
  }

  // 在所有子项都卸载后，删除dom树中的节点
  removeChildDom(parentDom, vNode.realNode);
  var realNodeNext = getSiblingDom(vNode);
  insertDom(parentDom, cloneDom, realNodeNext);
  vNode.realNode = cloneDom;
  attachRef(vNode);
  FlagUtils.removeFlag(vNode, Clear);
  vNode.clearChild = null;
}
function submitDeletion(vNode) {
  // 遍历所有子节点：删除dom节点，detach ref 和 调用componentWillUnmount()
  unmountDomComponents(vNode);

  // 置空vNode
  clearVNode(vNode);
}
function submitUpdate(vNode) {
  switch (vNode.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
      {
        // 执行useLayoutEffect的remove方法
        callUseLayoutEffectRemove(vNode);
        break;
      }
    case DomComponent:
    case DomText:
      {
        submitDomUpdate(vNode.tag, vNode);
        break;
      }
    case SuspenseComponent:
      {
        submitSuspenseComponent(vNode);
        listenToPromise(vNode);
        break;
      }
  }
}
function submitSuspenseComponent(vNode) {
  var childStatus = vNode.suspenseState.childStatus;
  if (childStatus !== SuspenseChildStatus.Init) {
    hideOrUnhideAllChildren(vNode.child, childStatus === SuspenseChildStatus.ShowFallback);
  }
}
function submitResetTextContent(vNode) {
  clearText(vNode.realNode);
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var rootThrowError = null;

// 防止死循环调用update
var LOOPING_UPDATE_LIMIT = 50;
var loopingUpdateCount = 0;
var lastRoot = null;
function submitToRender(treeRoot) {
  treeRoot.shouldUpdate = treeRoot.childShouldUpdate;
  // 置空task，让才能加入新的render任务
  treeRoot.task = null;
  var startVNode = getStartVNode();
  if (FlagUtils.hasAnyFlag(startVNode)) {
    // 把自己加上
    if (startVNode.dirtyNodes === null) {
      startVNode.dirtyNodes = [startVNode];
    } else {
      startVNode.dirtyNodes.push(startVNode);
    }
  }
  var dirtyNodes = startVNode.dirtyNodes;
  if (dirtyNodes !== null && dirtyNodes.length) {
    var preMode = copyExecuteMode();
    changeMode(InRender, true);
    prepareForSubmit();
    // before submit阶段
    beforeSubmit(dirtyNodes);

    // submit阶段
    submit(dirtyNodes);
    resetAfterSubmit();

    // after submit阶段
    afterSubmit(dirtyNodes);
    setExecuteMode(preMode);
    dirtyNodes.length = 0;
    startVNode.dirtyNodes = null;
  }
  if (isSchedulingEffects()) {
    setSchedulingEffects(false);
  }

  // 统计root同步重渲染的次数，如果太多可能是无线循环
  countLoopingUpdate(treeRoot);

  // 在退出`submit` 之前始终调用此函数，以确保任何已计划在此根上执行的update被执行。
  tryRenderFromRoot(treeRoot);
  if (rootThrowError) {
    var error = rootThrowError;
    rootThrowError = null;
    throw error;
  }
  return null;
}
function beforeSubmit(dirtyNodes) {
  var node;
  var nodesLength = dirtyNodes.length;
  for (var i = 0; i < nodesLength; i++) {
    node = dirtyNodes[i];
    try {
      if ((node.flags & Snapshot) === Snapshot) {
        callBeforeSubmitLifeCycles(node);
      }
    } catch (error) {
      handleSubmitError(node, error);
    }
  }
}
function submit(dirtyNodes) {
  var node;
  var nodesLength = dirtyNodes.length;
  var isAdd;
  var isUpdate;
  var isDeletion;
  var isClear;
  for (var i = 0; i < nodesLength; i++) {
    node = dirtyNodes[i];
    try {
      if ((node.flags & ResetText) === ResetText) {
        submitResetTextContent(node);
      }
      if ((node.flags & Ref) === Ref) {
        if (!node.isCreated) {
          // 需要执行
          detachRef(node, true);
        }
      }
      isAdd = (node.flags & Addition) === Addition;
      isUpdate = (node.flags & Update) === Update;
      if (isAdd && isUpdate) {
        // Addition
        submitAddition(node);
        FlagUtils.removeFlag(node, Addition);

        // Update
        submitUpdate(node);
      } else {
        isDeletion = (node.flags & Deletion) === Deletion;
        isClear = (node.flags & Clear) === Clear;
        if (isAdd) {
          submitAddition(node);
          FlagUtils.removeFlag(node, Addition);
        } else if (isUpdate) {
          submitUpdate(node);
        } else if (isDeletion) {
          submitDeletion(node);
        }
        if (isClear) {
          submitClear(node);
        }
      }
    } catch (error) {
      handleSubmitError(node, error);
    }
  }
}
function afterSubmit(dirtyNodes) {
  var node;
  var nodesLength = dirtyNodes.length;
  for (var i = 0; i < nodesLength; i++) {
    node = dirtyNodes[i];
    try {
      if ((node.flags & Update) === Update || (node.flags & Callback) === Callback) {
        callAfterSubmitLifeCycles(node);
      }
      if ((node.flags & Ref) === Ref) {
        attachRef(node);
      }
    } catch (error) {
      handleSubmitError(node, error);
    }
  }
}
function setRootThrowError(error) {
  if (!rootThrowError) {
    rootThrowError = error;
  }
}

// 统计root同步重渲染的次数，如果太多可能是无限循环
function countLoopingUpdate(root) {
  if (root.shouldUpdate) {
    if (root === lastRoot) {
      loopingUpdateCount++;
    } else {
      loopingUpdateCount = 0;
      lastRoot = root;
    }
  } else {
    loopingUpdateCount = 0;
  }
}
function checkLoopingUpdateLimit() {
  if (loopingUpdateCount > LOOPING_UPDATE_LIMIT) {
    loopingUpdateCount = 0;
    lastRoot = null;
    throw Error("The number of updates exceeds the upper limit " + LOOPING_UPDATE_LIMIT + ".\n      A component maybe repeatedly invokes setState on componentWillUpdate or componentDidUpdate.");
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

// 不可恢复错误
var unrecoverableErrorDuringBuild = null;

// 当前运行的vNode节点
var processing = null;

// 为重新进行深度遍历做准备
function resetProcessingVariables(startUpdateVNode) {
  // 创建processing
  processing = updateVNode(startUpdateVNode, startUpdateVNode === null || startUpdateVNode === void 0 ? void 0 : startUpdateVNode.props);
  setBuildResult(BuildInComplete);
  unrecoverableErrorDuringBuild = null;
}

// 收集有变化的节点，在submit阶段继续处理
function collectDirtyNodes(vNode, parent) {
  // 将子树和此vNode的所有效果附加到父树的效果列表中，子项的完成顺序会影响副作用顺序。
  var dirtyNodes = vNode.dirtyNodes;
  if (dirtyNodes !== null && dirtyNodes.length) {
    if (parent.dirtyNodes === null) {
      parent.dirtyNodes = dirtyNodes;
    } else {
      var _parent$dirtyNodes;
      (_parent$dirtyNodes = parent.dirtyNodes).push.apply(_parent$dirtyNodes, vNode.dirtyNodes);
      dirtyNodes.length = 0;
    }
    vNode.dirtyNodes = null;
  }
  if (FlagUtils.hasAnyFlag(vNode)) {
    if (parent.dirtyNodes === null) {
      parent.dirtyNodes = [vNode];
    } else {
      parent.dirtyNodes.push(vNode);
    }
  }
}

// ============================== 向上冒泡 ==============================

// 尝试完成当前工作单元，然后移动到下一个兄弟工作单元。如果没有更多的同级，请返回父vNode。
function bubbleVNode(vNode) {
  var node = vNode;
  do {
    var parent = node.parent;
    if ((node.flags & Interrupted) === InitFlag) {
      // vNode没有抛出异常
      componentRenders[node.tag].bubbleRender(node);

      // 设置node的childShouldUpdate属性
      updateChildShouldUpdate(node);
      if (parent !== null && node !== getStartVNode() && (parent.flags & Interrupted) === InitFlag) {
        collectDirtyNodes(node, parent);
      }
    }

    // 回到了开始遍历的节点
    if (node === getStartVNode()) {
      if (node.tag !== TreeRoot) {
        // 设置父node的childShouldUpdate属性
        updateParentsChildShouldUpdate(node);
      }
      processing = null;
      break;
    }
    var siblingVNode = node.next;
    if (siblingVNode !== null) {
      // 有兄弟vNode
      processing = siblingVNode;
      return;
    }

    // 继续遍历parent
    node = parent;
    // 更新processing，抛出异常时可以使用
    processing = node;
  } while (node !== null);

  // 修改结果
  if (getBuildResult() === BuildInComplete) {
    setBuildResult(BuildCompleted);
  }
}
function handleError(root, error) {
  if (processing === null || processing.parent === null) {
    // 这是一个致命的错误，因为没有祖先可以处理它
    setBuildResult(BuildFatalErrored);
    unrecoverableErrorDuringBuild = error;
    processing = null;
    return;
  }

  // 处理capture和bubble阶段抛出的错误
  handleRenderThrowError(processing, error);
  bubbleVNode(processing);
}

// 判断数组中节点的path的idx元素是否都相等
function isEqualByIndex(idx, pathArrays) {
  var first = pathArrays[0][idx];
  for (var i = 1; i < pathArrays.length; i++) {
    var pathArr = pathArrays[i];
    if (idx >= pathArr.length || first !== pathArr[idx]) {
      return false;
    }
  }
  return true;
}
function getChildByIndex(vNode, idx) {
  var node = vNode.child;
  for (var i = 0; i < idx; i++) {
    node = node.next;
  }
  return node;
}

// 从多个更新节点中，计算出开始节点。即：找到最近的共同的父辈节点
function calcStartUpdateVNode(treeRoot) {
  var toUpdateNodes = Array.from(treeRoot.toUpdateNodes);
  if (toUpdateNodes.length === 0) {
    return treeRoot;
  }
  if (toUpdateNodes.length === 1) {
    var toUpdateNode = toUpdateNodes[0];
    if (toUpdateNode.isCleared) {
      return treeRoot;
    } else {
      return toUpdateNodes[0];
    }
  }

  // 要计算的节点过多，直接返回根节点
  if (toUpdateNodes.length > 100) {
    return treeRoot;
  }
  var pathArrays = toUpdateNodes.map(function (node) {
    return getPathArr(node);
  });
  // 找出开始不相等的idx
  var commonPathEndIndex = 0;
  while (isEqualByIndex(commonPathEndIndex, pathArrays)) {
    commonPathEndIndex++;
  }
  // 得到相等的路径
  var startNodePath = pathArrays[0].slice(0, commonPathEndIndex);
  var node = treeRoot;
  for (var i = 1; i < startNodePath.length; i++) {
    var pathIndex = Number(startNodePath[i]);
    node = getChildByIndex(node, pathIndex);
    // 路径错误时，回退到从根更新
    if (node == null) {
      return treeRoot;
    }
  }
  return node;
}

// ============================== 深度遍历 ==============================
function buildVNodeTree(treeRoot) {
  var preMode = copyExecuteMode();
  changeMode(InRender, true);

  // 计算出开始节点
  var startVNode = calcStartUpdateVNode(treeRoot);
  // 缓存起来
  setStartVNode(startVNode);

  // 清空toUpdateNodes
  treeRoot.toUpdateNodes.clear();
  if (startVNode.tag !== TreeRoot) {
    // 不是根节点
    // 设置namespace，用于createElement
    var parent = startVNode.parent;
    while (parent !== null) {
      var tag = parent.tag;
      if (tag === DomComponent) {
        break;
      } else if (tag === TreeRoot || tag === DomPortal) {
        break;
      }
      parent = parent.parent;
    }

    // 当在componentWillUnmount中调用setState，parent可能是null，因为startVNode会被clear
    if (parent !== null) {
      resetNamespaceCtx(parent);
      setNamespaceCtx(parent, parent.realNode);
    }

    // 恢复父节点的context
    recoverTreeContext(startVNode);
  }

  // 重置环境变量，为重新进行深度遍历做准备
  resetProcessingVariables(startVNode);
  // devProps 用于插件手动更新props值
  if (startVNode.devProps !== undefined) {
    startVNode.props = startVNode.devProps;
    startVNode.devProps = undefined;
  }
  while (processing !== null) {
    try {
      // 捕获创建 vNodes
      var next = captureVNode(processing);
      if (next === null) {
        // 如果没有子节点，那么就完成当前节点，开始冒泡
        bubbleVNode(processing);
      } else {
        processing = next;
      }
    } catch (thrownValue) {
      handleError(treeRoot, thrownValue);
    }
  }
  if (startVNode.tag !== TreeRoot) {
    // 不是根节点
    // 恢复父节点的context
    resetTreeContext(startVNode);
  }
  setProcessingClassVNode(null);
  setExecuteMode(preMode);
}

// 在局部更新时，从上到下恢复父节点的context和PortalStack
function recoverTreeContext(vNode) {
  var contextProviders = [];
  var parent = vNode.parent;
  while (parent !== null) {
    if (parent.tag === ContextProvider) {
      contextProviders.unshift(parent);
    }
    if (parent.tag === DomPortal) {
      pushCurrentRoot(parent);
    }
    parent = parent.parent;
  }
  contextProviders.forEach(function (node) {
    setContext(node, node.props.value);
  });
}

// 在局部更新时，从下到上重置父节点的context
function resetTreeContext(vNode) {
  var parent = vNode.parent;
  while (parent !== null) {
    if (parent.tag === ContextProvider) {
      resetContext(parent);
    }
    if (parent.tag === DomPortal) {
      popCurrentRoot();
    }
    parent = parent.parent;
  }
}

// 总体任务入口
function renderFromRoot(treeRoot) {
  runAsyncEffects();
  pushCurrentRoot(treeRoot);
  // 1. 构建vNode树
  buildVNodeTree(treeRoot);

  // 致命错误直接抛出
  if (getBuildResult() === BuildFatalErrored) {
    throw unrecoverableErrorDuringBuild;
  }

  // 2. 提交变更
  submitToRender(treeRoot);
  popCurrentRoot();
  if (window.__HORIZON_DEV_HOOK__) {
    var hook = window.__HORIZON_DEV_HOOK__;
    // injector.js 可能在 Horizon 代码之后加载，此时无 __HORIZON_DEV_HOOK__ 全局变量
    // Horizon 代码初次加载时不会初始化 helper
    if (!hook.isInit) {
      injectUpdater();
    }
    hook.addIfNotInclude(treeRoot);
    hook.send(treeRoot);
  }
  return null;
}

// 尝试去渲染，已有任务就跳出
function tryRenderFromRoot(treeRoot) {
  if (treeRoot.shouldUpdate && treeRoot.task === null) {
    // 任务放进queue，但是调度开始还是异步的
    treeRoot.task = pushRenderCallback(renderFromRoot.bind(null, treeRoot));
  }
}

// 发起更新
function launchUpdateFromVNode(vNode) {
  var _treeRoot$toUpdateNod;
  // 检查循环调用
  checkLoopingUpdateLimit();

  // 从当前vNode向上遍历到根节点，修改vNode.shouldUpdate和parent.childShouldUpdate
  var treeRoot = updateShouldUpdateOfTree(vNode);
  if (treeRoot === null) {
    // 可能场景是：the componentWillUnmount method 或 useEffect cleanup function 方法中写异步任务，并且修改state。
    // 因为异步回调的时候root都可能被清除了。
    return;
  }

  // 保存待刷新的节点
  (_treeRoot$toUpdateNod = treeRoot.toUpdateNodes) === null || _treeRoot$toUpdateNod === void 0 ? void 0 : _treeRoot$toUpdateNod.add(vNode);
  if (checkMode(BySync) &&
  // 非批量
  !checkMode(InRender)) {
    // 不是渲染阶段触发

    // 业务直接调用Horizon.render的时候会进入这个分支，同步渲染。
    // 不能改成下面的异步，否则会有时序问题，因为业务可能会依赖这个渲染的完成。
    renderFromRoot(treeRoot);
  } else {
    tryRenderFromRoot(treeRoot);
    if (!isExecuting()) {
      // 同步执行
      callRenderQueueImmediate();
    }
  }
}

// ============================== HorizonDOM使用 ==============================
function runDiscreteUpdates() {
  if (checkMode(ByAsync) || checkMode(InRender)) {
    // 已经渲染，不能再同步执行待工作的任务，有可能是被生命周期或effect触发的事件导致的，如el.focus()
    return;
  }
  runAsyncEffects();
}
function asyncUpdates(fn) {
  var preMode = copyExecuteMode();
  changeMode(InEvent, true);
  try {
    for (var _len = arguments.length, param = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      param[_key - 1] = arguments[_key];
    }
    return fn.apply(void 0, param);
  } finally {
    setExecuteMode(preMode);
    if (!isExecuting()) {
      // 同步执行
      callRenderQueueImmediate();
    }
  }
}
function syncUpdates(fn) {
  var preMode = copyExecuteMode();
  // 去掉异步状态，添加同步状态
  changeMode(ByAsync, false);
  changeMode(BySync, true);
  try {
    return fn();
  } finally {
    setExecuteMode(preMode);
    if (!isExecuting()) {
      // 同步执行
      callRenderQueueImmediate();
    }
  }
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var isEffectHook = function (state) {
  return !!state.effect;
};
var isRefHook = function (state) {
  return Object.prototype.hasOwnProperty.call(state, 'current');
};
var isCallbackHook = function (state) {
  return Object.prototype.hasOwnProperty.call(state, 'func');
};
var isMemoHook = function (state) {
  return Object.prototype.hasOwnProperty.call(state, 'result');
};
var HookName = {
  StateHook: 'State',
  EffectHook: 'Effect',
  LayoutEffectHook: 'LayoutEffect',
  MemoHook: 'Memo',
  RefHook: 'Ref',
  ReducerHook: 'Reducer',
  CallbackHook: 'Callback'
};
var helper = {
  travelVNodeTree: function (rootVNode, fun) {
    var childFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    travelVNodeTree(rootVNode, fun, childFilter, rootVNode, null);
  },
  // 获取 hook 名，hIndex值和存储的值
  getHookInfo: function (hook) {
    var hIndex = hook.hIndex,
      state = hook.state;
    if (state.trigger) {
      if (state.isUseState) {
        return {
          name: HookName.StateHook,
          hIndex: hIndex,
          value: state.stateValue
        };
      } else if (state.reducer) {
        return {
          name: HookName.ReducerHook,
          hIndex: hIndex,
          value: state.stateValue
        };
      }
    } else if (isRefHook(state)) {
      return {
        name: HookName.RefHook,
        hIndex: hIndex,
        value: state.current
      };
    } else if (isEffectHook(state)) {
      var name = state.effectConstant == EffectConstant.LayoutEffect || EffectConstant.LayoutEffect | EffectConstant.DepsChange ? HookName.LayoutEffectHook : HookName.EffectHook;
      return {
        name: name,
        hIndex: hIndex,
        value: state.effect
      };
    } else if (isCallbackHook(state)) {
      return {
        name: HookName.CallbackHook,
        hIndex: hIndex,
        value: state.func
      };
    } else if (isMemoHook(state)) {
      return {
        name: HookName.MemoHook,
        hIndex: hIndex,
        value: state.result
      };
    }
    return null;
  },
  updateProps: function (vNode, props) {
    vNode.devProps = props;
    launchUpdateFromVNode(vNode);
  },
  updateState: function (vNode, nextState) {
    var instance = vNode.realNode;
    instance.setState(nextState);
  },
  updateHooks: function (vNode, hIndex, nextState) {
    var hooks = vNode.hooks;
    if (hooks) {
      var editHook = hooks[hIndex];
      var editState = editHook.state;
      // 暂时只支持更新 useState 的值
      if (editState.trigger && editState.isUseState) {
        editState.trigger(nextState);
      }
    } else {
      console.error('Target vNode is not a hook vNode: ', vNode);
    }
  },
  getComponentInfo: function (vNode) {
    var props = vNode.props,
      state = vNode.state,
      hooks = vNode.hooks;
    var info = {};
    if (props && Object.keys(props).length !== 0) {
      info['Props'] = props;
    }
    if (state && Object.keys(state).length !== 0) {
      info['State'] = state;
    }
    if (hooks && hooks.length !== 0) {
      var logHookInfo = [];
      hooks.forEach(function (hook) {
        var state = hook.state;
        if (state.trigger && state.isUseState) {
          logHookInfo.push(state.stateValue);
        }
      });
      info['Hooks'] = logHookInfo;
    }
    travelVNodeTree(vNode, function (node) {
      if (node.tag === DomComponent) {
        var _dom$parentNode;
        // 找到组件的第一个dom元素，返回它所在父节点的全部子节点
        var dom = node.realNode;
        info['Nodes'] = dom === null || dom === void 0 ? void 0 : (_dom$parentNode = dom.parentNode) === null || _dom$parentNode === void 0 ? void 0 : _dom$parentNode.childNodes;
        return true;
      }
      return false;
    }, null, vNode, null);
    return info;
  },
  getElementTag: function (element) {
    return getElementTag(element);
  }
};
function injectUpdater() {
  var hook = window.__HORIZON_DEV_HOOK__;
  if (hook) {
    hook.init(helper);
  }
}
injectUpdater();

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function isObject(anyThing) {
  return Object.prototype.toString.call(anyThing) === '[object Object]';
}
function isBuiltinTag(type) {
  return [TYPE_FRAGMENT, TYPE_SUSPENSE].includes(type);
}
function isBuiltinComponent(type) {
  return [TYPE_MEMO, TYPE_PROVIDER, TYPE_LAZY, TYPE_FORWARD_REF, TYPE_CONTEXT].includes(type);
}
/**
 * 获取传入的element的类型
 * 1. fragment, suspense 属于内置标签，类型位于type
 * 2. memo, lazy, forwardRef 属于包装函数，产生新的对象，类型位于type.vtype
 * 3. Context.Provider/Consumer 的类型是框架定义的对象，类型位于type.vtype
 * 4. portal比较特殊，函数结果直接可以作为element，类型位于vtype
 * @param ele
 */
function getType(ele) {
  if (isObject(ele)) {
    var type = ele.type;
    if (isBuiltinTag(type)) {
      return type;
    }
    var vtypeOfType = type === null || type === void 0 ? void 0 : type.vtype;
    if (isBuiltinComponent(vtypeOfType)) {
      return vtypeOfType;
    }
    var vtype = ele.vtype;
    if (TYPE_PORTAL === vtype) {
      return vtype;
    }
  }
  return undefined;
}
function isElement(ele) {
  return isObject(ele) && ele.vtype === TYPE_COMMON_ELEMENT;
}
function isFragment(ele) {
  return getType(ele) === TYPE_FRAGMENT;
}
function isForwardRef(ele) {
  return getType(ele) === TYPE_FORWARD_REF;
}
function isLazy(ele) {
  return getType(ele) === TYPE_LAZY;
}
function isMemo(ele) {
  return getType(ele) === TYPE_MEMO;
}
function isPortal(ele) {
  return getType(ele) === TYPE_PORTAL;
}
function isContextProvider(ele) {
  return getType(ele) === TYPE_PROVIDER;
}

// Context.consumer的类型就是context的类型
function isContextConsumer(ele) {
  return getType(ele) === TYPE_CONTEXT;
}
function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function' || isBuiltinTag(type)) {
    return true;
  }
  if (isObject(type)) {
    if (isBuiltinComponent(type.vtype)) {
      return true;
    }
  }
  return false;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function createThunkMiddleware(extraArgument) {
  return function (store) {
    return function (next) {
      return function (action) {
        // This gets called for every action you dispatch.
        // If it's a function, call it.
        if (typeof action === 'function') {
          return action(store.dispatch, store.getState.bind(store), extraArgument);
        }

        // Otherwise, just continue processing this action as usual
        return next(action);
      };
    };
  };
}
var thunk = createThunkMiddleware();
// @ts-ignore
thunk.withExtraArgument = createThunkMiddleware;

var DefaultContext = createContext(null);
function Provider(_ref) {
  var store = _ref.store,
    _ref$context = _ref.context,
    context = _ref$context === void 0 ? DefaultContext : _ref$context,
    children = _ref.children;
  var Context = context; // NOTE: bind redux API to horizon API requires this renaming;
  return createElement(Context.Provider, {
    value: store
  }, children);
}
function createStoreHook(context) {
  return function () {
    return useContext(context);
  };
}
function createSelectorHook(context) {
  var store = createStoreHook(context)();
  return function () {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {
      return state;
    };
    var _useState = useState(false),
      b = _useState[0],
      fr = _useState[1];
    useEffect(function () {
      var unsubscribe = store.subscribe(function () {
        return fr(!b);
      });
      return function () {
        unsubscribe();
      };
    });
    return selector(store.getState());
  };
}
function createDispatchHook(context) {
  var store = createStoreHook(context)();
  return function () {
    return function (action) {
      store.dispatch(action);
    };
  }.bind(store);
}
var useSelector = function (selector) {
  return createSelectorHook(DefaultContext)(selector);
};
var useDispatch = function () {
  return createDispatchHook(DefaultContext)();
};
var useStore = function () {
  return createStoreHook(DefaultContext)();
};
function connect(mapStateToProps, mapDispatchToProps, mergeProps, options) {
  if (!options) {
    options = {};
  }

  //this component should bear the type returned from mapping functions
  return function (Component) {
    var _options;
    var useStore = createStoreHook(((_options = options) === null || _options === void 0 ? void 0 : _options.context) || DefaultContext);

    //this component should mimic original type of component used
    var Wrapper = function (props) {
      var _options2;
      var _useState2 = useState(true),
        f = _useState2[0],
        forceReload = _useState2[1];
      var store = useStore();
      useEffect(function () {
        var unsubscribe = store.subscribe(function () {
          return forceReload(!f);
        });
        return function () {
          unsubscribe();
        };
      });
      var previous = useRef({
        state: {},
        mappedState: {}
      });
      var mappedState;
      if ((_options2 = options) !== null && _options2 !== void 0 && _options2.areStatesEqual) {
        if (options.areStatesEqual(previous.current.state, store.getState())) {
          mappedState = previous.current.mappedState;
        } else {
          mappedState = mapStateToProps ? mapStateToProps(store.getState(), props) : {};
          previous.current.mappedState = mappedState;
        }
      } else {
        mappedState = mapStateToProps ? mapStateToProps(store.getState(), props) : {};
        previous.current.mappedState = mappedState;
      }
      var mappedDispatch = {};
      if (mapDispatchToProps) {
        if (typeof mapDispatchToProps === 'object') {
          Object.entries(mapDispatchToProps).forEach(function (_ref2) {
            var key = _ref2[0],
              value = _ref2[1];
            mappedDispatch[key] = function () {
              store.dispatch(value.apply(void 0, arguments));
            };
          });
        } else {
          mappedDispatch = mapDispatchToProps(store.dispatch, props);
        }
      }
      var mergedProps = (mergeProps || function (state, dispatch, originalProps) {
        return _extends({}, state, dispatch, originalProps);
      })(mappedState, mappedDispatch, props);
      previous.current.state = store.getState();
      var node = createElement(Component, mergedProps);
      return node;
    };
    return Wrapper;
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createStore(reducer, preloadedState, enhancers) {
  var store = createStore$1({
    id: 'defaultStore',
    state: {
      stateWrapper: preloadedState
    },
    actions: {
      dispatch: function (state, action) {
        var result;
        if (state.stateWrapper !== undefined && state.stateWrapper !== null) {
          result = reducer(state.stateWrapper, action);
        } else {
          result = reducer(undefined, action);
        }
        if (result === undefined) {
          return;
        } // NOTE: reducer should never return undefined, in this case, do not change state
        // mergeData(state,result);
        state.stateWrapper = result;
      }
    },
    options: {
      isReduxAdapter: true
    }
  })();

  // store.$subscribe(()=>{
  //   console.log('changed');
  // });

  var result = {
    reducer: reducer,
    getState: function () {
      return store.$s.stateWrapper;
    },
    subscribe: function (listener) {
      store.$subscribe(listener);
      return function () {
        store.$unsubscribe(listener);
      };
    },
    replaceReducer: function (newReducer) {
      reducer = newReducer;
    },
    _horizonXstore: store,
    dispatch: store.$a.dispatch
  };
  enhancers && enhancers(result);
  result.dispatch({
    type: 'HorizonX'
  });
  store.reduxHandler = result;
  return result;
}
function combineReducers(reducers) {
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments.length > 1 ? arguments[1] : undefined;
    var newState = {};
    Object.entries(reducers).forEach(function (_ref2) {
      var key = _ref2[0],
        reducer = _ref2[1];
      newState[key] = reducer(state[key], action);
    });
    return newState;
  };
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function (store) {
    return applyMiddlewares(store, middlewares);
  };
}
function applyMiddlewares(store, middlewares) {
  middlewares = middlewares.slice();
  middlewares.reverse();
  var dispatch = store.dispatch;
  middlewares.forEach(function (middleware) {
    dispatch = middleware(store)(dispatch);
  });
  store.dispatch = dispatch;
}
function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};
  Object.entries(actionCreators).forEach(function (_ref3) {
    var key = _ref3[0],
      value = _ref3[1];
    boundActionCreators[key] = function () {
      dispatch(value.apply(void 0, arguments));
    };
  });
  return boundActionCreators;
}
function compose() {
  for (var _len2 = arguments.length, middlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    middlewares[_key2] = arguments[_key2];
  }
  return function (store, extraArgument) {
    var val;
    middlewares.reverse().forEach(function (middleware, index) {
      if (!index) {
        val = middleware(store, extraArgument);
        return;
      }
      val = middleware(val);
    });
    return val;
  };
}

// HorizonX batches updates by default, this function is only for backwards compatibility
function batch(fn) {
  fn();
}

var reduxAdapter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createStore: createStore,
  combineReducers: combineReducers,
  applyMiddleware: applyMiddleware,
  bindActionCreators: bindActionCreators,
  compose: compose,
  batch: batch,
  thunk: thunk,
  Provider: Provider,
  useSelector: useSelector,
  useStore: useStore,
  useDispatch: useDispatch,
  connect: connect,
  createSelectorHook: createSelectorHook,
  createDispatchHook: createDispatchHook
});

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

function watch(stateVariable, listener) {
  listener = listener.bind(null, stateVariable);
  stateVariable.addListener(listener);
  return function () {
    stateVariable.removeListener(listener);
  };
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
// act用于测试，作用是：如果fun触发了刷新（包含了异步刷新），可以保证在act后面的代码是在刷新完成后才执行。
function act(fun) {
  var funRet = asyncUpdates(fun);
  callRenderQueue();

  // 如果fun返回的是Promise
  if (isPromise(funRet)) {
    // testing-library会返回Promise
    return {
      then: function (resolve, reject) {
        funRet.then(function () {
          if (typeof setImmediate === 'function') {
            // 通过setImmediate回调，用于等待业务的setTimeout完成
            setImmediate(function () {
              callRenderQueue();
              resolve();
            });
          } else {
            callRenderQueue();
            resolve();
          }
        }, function (err) {
          reject(err);
        });
      }
    };
  } else {
    return {
      then: function (resolve) {
        resolve();
      }
    };
  }
}
function callRenderQueue() {
  callRenderQueueImmediate();
  runAsyncEffects();
  // effects可能产生刷新任务，这里再执行一次
  callRenderQueueImmediate();
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
function createRoot(children, container, callback) {
  // 清空容器
  var child = container.lastChild;
  while (child) {
    container.removeChild(child);
    child = container.lastChild;
  }

  // 调度器创建根节点，并给容器dom赋vNode结构体
  var treeRoot = createTreeRootVNode(container);
  container._treeRoot = treeRoot;

  // 执行回调
  if (typeof callback === 'function') {
    var cb = callback;
    callback = function () {
      var instance = getFirstCustomDom(treeRoot);
      cb.call(instance);
    };
  }

  // 建VNode树，启动页面绘制
  syncUpdates(function () {
    startUpdate(children, treeRoot, callback);
  });
  return treeRoot;
}
function executeRender(children, container, callback) {
  var treeRoot = container._treeRoot;
  if (!treeRoot) {
    treeRoot = createRoot(children, container, callback);
  } else {
    // container被render过
    if (typeof callback === 'function') {
      var cb = callback;
      callback = function () {
        var instance = getFirstCustomDom(treeRoot);
        cb.call(instance);
      };
    }
    // 执行更新操作
    startUpdate(children, treeRoot, callback);
  }
  return getFirstCustomDom(treeRoot);
}
function findDOMNode(domOrEle) {
  if (domOrEle == null) {
    return null;
  }

  // 普通节点
  if (isElement$1(domOrEle)) {
    return domOrEle;
  }

  // class的实例
  return findDOMByClassInst(domOrEle);
}

// 情况根节点监听器
function removeRootEventLister(container) {
  var events = container._treeRoot.$EV;
  if (events) {
    Object.keys(events).forEach(function (event) {
      var listener = events[event];
      if (listener) {
        container.removeEventListener(event, listener);
        events[event] = null;
      }
    });
  }
}

// 卸载入口
function destroy(container) {
  if (container && container._treeRoot) {
    syncUpdates(function () {
      executeRender(null, container, function () {
        removeRootEventLister(container);
        container._treeRoot = null;
      });
    });
    return true;
  }
  return false;
}

/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
var Horizon = {
  Children: Children,
  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,
  createContext: createContext,
  forwardRef: forwardRef,
  getProcessingVNode: getProcessingVNode,
  lazy: lazy,
  memo: memo,
  useDebugValue: useDebugValue,
  useCallback: useCallback,
  useContext: useContext,
  useEffect: useEffect,
  useImperativeHandle: useImperativeHandle,
  useLayoutEffect: useLayoutEffect,
  useRenderEffect: useRenderEffect,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  Fragment: TYPE_FRAGMENT,
  Profiler: TYPE_PROFILER,
  StrictMode: TYPE_STRICT_MODE,
  Suspense: TYPE_SUSPENSE,
  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: isValidElement,
  render: executeRender,
  createPortal: createPortal,
  unstable_batchedUpdates: asyncUpdates,
  findDOMNode: findDOMNode,
  unmountComponentAtNode: destroy,
  act: act,
  flushSync: syncUpdates,
  createStore: createStore$1,
  useStore: useStore$1,
  clearStore: clearStore,
  reduxAdapter: reduxAdapter,
  watch: watch,
  isFragment: isFragment,
  isElement: isElement,
  isValidElementType: isValidElementType,
  isForwardRef: isForwardRef,
  isLazy: isLazy,
  isMemo: isMemo,
  isPortal: isPortal,
  isContextProvider: isContextProvider,
  isContextConsumer: isContextConsumer,
  registerComponent: registerComponent
};
var version = "0.0.38";

exports.Children = Children;
exports.Component = Component;
exports.Fragment = TYPE_FRAGMENT;
exports.Profiler = TYPE_PROFILER;
exports.PureComponent = PureComponent;
exports.StrictMode = TYPE_STRICT_MODE;
exports.Suspense = TYPE_SUSPENSE;
exports.act = act;
exports.clearStore = clearStore;
exports.cloneElement = cloneElement;
exports.createContext = createContext;
exports.createElement = createElement;
exports.createPortal = createPortal;
exports.createRef = createRef;
exports.createStore = createStore$1;
exports["default"] = Horizon;
exports.findDOMNode = findDOMNode;
exports.flushSync = syncUpdates;
exports.forwardRef = forwardRef;
exports.getProcessingVNode = getProcessingVNode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isValidElement = isValidElement;
exports.isValidElementType = isValidElementType;
exports.lazy = lazy;
exports.memo = memo;
exports.reduxAdapter = reduxAdapter;
exports.registerComponent = registerComponent;
exports.render = executeRender;
exports.unmountComponentAtNode = destroy;
exports.unstable_batchedUpdates = asyncUpdates;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useRenderEffect = useRenderEffect;
exports.useState = useState;
exports.useStore = useStore$1;
exports.version = version;
exports.watch = watch;
